<doc sitename="EIKE - Europ√§isches Institut f√ºr Klima &amp; Energie" title="Der alte Code und das neue Virus" author="Admin" date="2020-05-20" source="https://eike-klima-energie.eu/2020/05/20/der-alte-code-und-das-neue-virus/" hostname="eike-klima-energie.eu" excerpt="von G√ºnter Frank Mit Aktualisierung vom 20.5.20 Zwei Spezialisten haben sich die Computer Modellierung des britischen Wissenschaftlers Neil Ferguson, der die Regierung in Sachen Corona beriet, n√§her angesehen. Er sagte Millionen von Corona-Toten voraus und beeinflusste weltweit die Lockdown-Ma√ünahmen." categories="Energie;Klima" tags="" fingerprint="xVPovZoz7V3rWYeWSs4HaifPxJo=">
  <main>
    <p>Das Urteil der IT-Fachleute ist verheerend: Es handele sich wom√∂glich um den zerst√∂rerischten Softwarefehler aller Zeiten, was die wirtschaftlichen Kosten und die Zahl der verlorenen Leben anbetreffe. Beachten Sie bitte den Nachtrag/ die Aktualisierung am Ende des Textes-<lb/>Erinnern Sie sich noch an die Modellrechnung des britischen Wissenschaftlers des Imperial College in London, Neil Ferguson, der die Regierung in Sachen Corona beriet und die wissenschaftliche Grundlage f√ºr die strengen Ausgangsbeschr√§nkungen in Gro√übritannien lieferte? Er prognostizierte 2,2 Millionen Coronatote f√ºr die USA und 500.000 f√ºr Gro√übritannien. Auf diesem Modell beruhte letztlich die Corona-Strategie der Abflachung der Kurve ‚Äûflattening the curve‚Äú durch Social Distancing und Lockdown.<lb/>Heute erweist sich dieses Modell als hysterische √úbersch√§tzung. Selbst die vielen Coronatoten in Gro√übritannien (ich m√∂chte stets anf√ºgen, dass diese Coronatoten auch die sehr wahrscheinlich hohe Zahl an Verstorbenen beinhalten, die unn√∂tig intubiert wurden), werden bei weitem nicht die vorderen R√§nge der j√§hrlichen Todesursachenstatistik einnehmen, mit oder ohne Lockdown.</p>
    <head rend="h3">Gescheiterte Venus-Raumsonde</head>
    <p>David Richards und Konstantin Boudnik, Gr√ºnder, CEO sowie Sotfwareleiter von WANdisco bezeichnen diese Modellrechnung nun als den wom√∂glich zerst√∂rerischsten Softwarefehler aller Zeiten:<lb/>‚ÄûDie Modellierung nicht-pharmazeutischer Interventionen f√ºr Covid-19 durch das Imperial College, die dazu beitrug, Gro√übritannien und andere L√§nder zu drakonischen Lockdowns zu bewegen, wird die gescheiterte Venus-Raumsonde abl√∂sen, die als der verheerendste Softwarefehler aller Zeiten in die Geschichte eingehen k√∂nnte, was die wirtschaftlichen Kosten und die Zahl der verlorenen Leben betrifft.‚Äú<lb/>Original auf Englisch hei√üt es:<lb/>‚ÄûImperial College‚Äôs modelling of non-pharmaceutical interventions for Covid-19 which helped persuade the UK and other countries to bring in draconian lockdowns will supersede the failed Venus space probe could go down in history as the most devastating software mistake of all time, in terms of economic costs and lives lost.‚Äù<lb/>Im britischen Telegraph fragen die beiden anerkannten Programmier-Spezialisten, warum die Regierung keine zweite Meinung eingeholt hat, bevor sie das Covid-Computer-Modell des Imperial College akzeptiert hat. Weiter schreiben Sie:<lb/>‚ÄûSeit der Ver√∂ffentlichung des Mikrosimulationsmodells von Imperial haben diejenigen von uns, die ein berufliches und pers√∂nliches Interesse an der Softwareentwicklung haben, den Code studiert, auf dem die politischen Entscheidungstr√§ger ihre schicksalhafte Entscheidung basierten, unsere mehrere Billionen Pfund schwere Wirtschaft einzumotten und Millionen von Menschen in Armut und Not zu st√ºrzen. Und wir waren zutiefst beunruhigt √ºber das, was wir entdeckt haben. Das Modell scheint v√∂llig unzuverl√§ssig zu sein, und Sie w√ºrden nicht Ihr Leben darauf verwetten.‚Äú</p>
    <head rend="h3">Schon vor 20 Jahren Schnee von gestern</head>
    <p>Das Modell von Imperial scheine auf einer Programmiersprache namens Fortran zu basieren, die schon vor 20 Jahren Schnee von gestern gewesen sei. Ihr Code sei auch f√ºr die gescheiterte Raumsonden-Mission verwendet worden, wie f√ºr die Raumsonde Mariner 1. Und sie sagen: ‚ÄûIn unserer kommerziellen Realit√§t w√ºrden wir jeden f√ºr die Entwicklung eines solchen Codes feuern, und jedes Unternehmen, das sich bei der Herstellung von Software zum Verkauf darauf verl√§sst, w√ºrde wahrscheinlich pleite gehen‚Äú.<lb/>Weiter schreiben Sie: Die Modelle m√ºssten in der Lage sein, den grundlegenden wissenschaftlichen Test zu bestehen, um bei gleichen Ausgangsparametern die gleichen Ergebnisse zu erzielen. Andernfalls gibt es einfach keine M√∂glichkeit, zu wissen, ob sie zuverl√§ssig sein werden.<lb/>Das Resumee der beiden Kritiker: ‚ÄûTats√§chlich verwenden viele globale Industrien erfolgreich deterministische Modelle, die den Zufallsfaktor ber√ºcksichtigen. Kein Chirurg w√ºrde einen Herzschrittmacher bei einem Herzpatienten einsetzen, wenn er w√ºsste, dass er auf einem wohl unvorhersehbaren Ansatz beruht, aus Angst, den hippokratischen Eid zu gef√§hrden. Warum um alles in der Welt w√ºrde die Regierung ihr Vertrauen darauf setzen, wenn das gesamte Wohlergehen unserer Nation auf dem Spiel steht?‚Äú</p>
    <head rend="h3">Nachtrag vom 20.Mai 2020</head>
    <p>Mein letzter Beitrag wurde in den Leserbriefen zur Recht kritisiert, weil ich mich eben fachfremd bin bzgl. Computer Modellen. Leser Daniel Hirsch hat das ganze Problem mit dem Imperial Model viel besser und treffender erkl√§rt. Imperial Model, Computersprache und Schuster bleib bei deinen Leisten. Beim letzten Beitrag, habe ich mein Fachgebiet verlassen, und einige Leser erweiterten daraufhin meinen Horizont. Zu Recht, denn ich werfe es beispielsweise Prof. Christian Drosten vor, dass er sich ausserhalb seiner Fachkompetenz z.B. zur Epidemiologie √§ussert und genau deswegen scheitert. Ein Virologe muss vor den Gefahren warnen, aber Epidemiologie bedeutet gerade eben nicht, stets vom worst case auszugehen, sondern sich um echte Daten zu k√ºmmern und diese im Sinne von Wahrscheinlichkeiten zu deuten. Daniel Hirsch ist Computerfachmann und kann die Problematik des Imperial Models deshalb viel treffender beschreiben. Ich m√∂chte Ihnen mit seiner Erlaubnis seine Zuschrift an mich nicht vorenthalten:<lb/>Als Mathematiker mit der Spezialisierung numerische Mathematik habe ich w√§hrend meines Studiums an der Uni Heidelberg zahlreiche Supercomputer entworfen, betrieben und eigene Modelle entwickelt (mit Schwerpunkt in der nichtlinearen Optimierung und im Bereich unstetige Galerkin-Verfahren). Deshalb m√∂chte ich gern die Gelegenheit nutzen und ein bisschen von meiner Expertise beitragen.<lb/>1. Programmiersprache<lb/>Die Programmiersprache ist letztlich nur eine Form um Maschinensprache (die sprichw√∂rtlichen ‚Äûbits and bytes‚Äú) f√ºr den Menschen lesbar bzw. menschliches strukturiertes Denken f√ºr den Computer ausf√ºhrbar zu machen. Die Programmiersprachen sind dabei in ihren Grundfunktionen gleich. In jeder Sprache finden sich einfache Strukturen, wie Schleifen (Z√§hlschleife: ‚Äûmache irgendwas n mal‚Äú; vorpr√ºfende Schleife: ‚Äûso lange eine Bedingung erf√ºllt ist, mache irgendwas‚Äú; nachpr√ºfende Schleife: ‚Äûwenn irgendeine Bedingung richtig ist, mache das, was Du vorher gemacht hast nochmal‚Äú), Bedingungen (‚Äûwenn irgendwas richtig ist, mache folgendes, anderenfalls was anderes‚Äú), Zugriffe auf Dateisysteme oder auf den Monitor/Tastatur. Zudem gibt es inzwischen in vielen Programmiersprachen auch die M√∂glichkeit komplexere Strukturen, wie z.B. vererbbare Objekte, Templates, etc. zu bauen. Das im Detail auszuleuchten sprengt den Rahmen.<lb/>Fortran ist in der Tat eine recht alte Programmiersprache (von 1957), die ihre Vor- und Nachteile hat. Das zu diskutieren l√∂st in aller Regel ‚Äì wie so oft in der IT ‚Äì einen Glaubenskampf aus. Die Unterschiede in den Programmiersprachen liegen neben der offensichtlichen anderen Syntax in der Regel eine Ebene tiefer, also wie performant ein Compiler ist, wie performant das erzeugte binary ist, wie gut der Code auf andere Plattformen √ºbertragen werden kann, etc. Es spielt aber auch eine Rolle, wie stark die Kommerzialisierung einer Programmiersprache ist. Programmiersprachen, die f√ºr kommerzielle Software verwendet werden, sind oft st√§rker unterst√ºtzt und entwickeln sich schneller als weniger popul√§re Sprachen. Die wesentlichen Vorteile von Fortran aus meiner pers√∂nlichen Sicht sind, dass die Lernkurve um Fortran programmieren zu k√∂nnen, recht flach und kurz ist und sehr viel frei verf√ºgbarer Code existiert. Es gibt Literatur, wonach gute Fortran Compiler bei Array-basierten Anwendungen schnelleren Code als flexiblere Sprachen wie z.B. C++ produzieren k√∂nnen sollen. Das l√§√üt sich in der Regel aber mit ‚Äûbesserem‚Äú Code kompensieren. Richtig ist in jedem Fall, dass gerade im universit√§ren Bereich Fortran weite Verbreitung hat und es eine lebendige Community gibt, die die vorhandenen Compiler und den Standard (zuletzt 2018) weiterentwickelt. Es ist daher nicht ungew√∂hnlich Programme in Fortran in diesem Umfeld zu finden.<lb/>2. Universit√§re Softwareentwicklung<lb/>In Mathematik und Physik ist es weit verbreitet Software f√ºr verschiedene Zwecke zu entwickeln. Oft wird die Software f√ºr eine bestimmte Klasse Gro√ürechner (z.B. Parallelrechner) oder gar nur f√ºr einen ganz bestimmten Rechner entwickelt. Im Vordergrund steht dabei immer die Mathematik oder die Physik und weniger die informatische Qualit√§t der Implementierung. Da es ein recht gro√üer Aufwand ist, jedes Einzelproblem, welches man l√∂sen m√∂chte, dediziert zu programmieren, verwendet man den Code in sogenannten Bibliotheken immer wieder. Darin sind mathematische Formen, wie Vektoren, Tensoren, Gitter, etc. ebenso wie die mathematischen Modelle und Algorithmen, die mit diesen Strukturen umgehen m√ºssen, bereits implementiert. Diese Bibliotheken werden dann ‚Äì meist kostenlos ‚Äì allen anderen Wissenschaftlern zur Verf√ºgung gestellt. Die Entwicklungsteams sind klein und es wird nicht nach kommerziellen Standards entwickelt. Man kann nicht erwarten, dass die Software einem IT-Qualit√§tsassessment standhalten wird. Daraus zu folgern, dass die Software falsch rechnet, ist jedoch voreilig.<lb/>3. Mathematische Modellierung<lb/>Wenn ein Modell aufgestellt wird, bedient man sich f√ºr gew√∂hnlich zun√§chst der Mathematik und zwar ganz klassisch mit Tafel und Kreide. Die Implementierung erfolgt danach mit Hilfe der vorhandenen Bibliotheken. Wenn das Modell implementiert ist, verwendet man √ºblicherweise Testdaten und -probleme um zu zeigen, dass die Software funktioniert. Oft werden die Ergebnisse auch publiziert, da neue Modelle / Algorithmen in der Regel nur dann implementiert werden, wenn sie aus wissenschaftlicher Sicht neu sind oder wenn die Implementierung aus irgendeinem Grund besser ist als bisherige Implementierungen (z.B. schnellere Konvergenz, geringerer notwendiger Speicherplatz, h√∂here Genauigkeit, etc.). Andernfalls macht sich keiner die M√ºhe vorhandene Modelle nochmal zu implementieren ‚Äì au√üer vielleicht im Rahmen einer √úbung zu einer Vorlesung. Hier liegt auch der Unterschied zur Venus-Sonde. Die Software f√ºr die Venussonde war f√ºr eine einmalige Anwendung gedacht (n√§mlich genau diese Sonde auf dieser Mission) und konnte unter Echtbedingungen nie getestet werden. Die Modelle von Neil Ferguson sind mehrfach getestet und mit anderen Modellen gegen gerechnet worden. Das schlie√üt Programmierfehler freilich nicht aus, aber bisher gibt es keinen Hinweis auf einen solchen. Wahrscheinlicher sind Fehler in den Ausgangsdaten.<lb/>4. Numerischer Fehler<lb/>Das gr√∂√üte Problem bei mathematischen Modellen ist der sogenannte numerische Fehler. Die meisten Strukturen in der allt√§glichen Mathematik basieren auf den reellen Zahlen. Ohne die reellen Zahlen funktioniert unsere Welt nicht mehr. Bestes Beispiel: Der Umfang eines Kreises. Ohne die Zahl pi, ist der Umfang nicht exakt zu errechnen. Dummerweise hat pi unendlich viele Nachkommastellen (die wir logischerweise auch nicht alle kennen). Daher kann man eine solche Zahl nicht auf einem Computer abbilden, der ja nur √ºber endlich viel Speicher verf√ºgt, selbst wenn wir alle Nachkommastellen kennen w√ºrden. Man behilft sich durch Runden der Zahl (typischerweise auf 16 Stellen) . F√ºr allt√§gliche Probleme reicht die Rundungslogik auf normalen Rechnern v√∂llig aus. Allerdings gibt es noch ein weiteres Problem: Ein mathematisches Modell besteht aus sehr vielen Einzeloperationen. Die Rechenoperationen reagieren dabei unterschiedlich gut auf die Eingangsdaten und die Einzelfehler jeder Operation k√∂nnen sich im gesamten Modell aufschaukeln. Es ist daher sehr wichtig, die Stabilit√§t/Zuverl√§ssigkeit des Algorithmus gegen derartige Effekte zu kennen.<lb/>5. Eingangsfehler<lb/>Bei allen Algorithmen gilt das ‚Äûshit-in-shit-out‚Äú-Prinzip. Arbeitet man mit Daten, die einen gro√üen Fehler beinhalten, dann kommt am Ende ein noch viel gr√∂√üerer Fehler raus (wie viel schlimmer sagt uns die Stabilit√§t eines Modells). Die Programmiersprache ist nicht entscheidend, denn es kommt √ºberhaupt nicht darauf an, ob ein mathematisches Modell in Fortran, C++, Basic oder von mir aus auf Lochkarten implementiert wird. Genauso wenig wie es darauf ankommen sollte, ob man eine Addition mit dem Rechenschieber, dem Abakus, einem Taschenrechner oder im Kopf durchf√ºhrt. Ich bin davon √ºberzeugt, dass das Problem des Modells von Neil Ferguson in den Eingangsdaten liegt. Das von ihm verwendete Modell basiert im Wesentlichen auf folgenden Daten:</p>
    <list>
      <item>Todesrate (CFR) in Hubei ‚Äì hierzu hat sich Neil Ferguson 39 Todesf√§lle von diversen Webseiten zusammen gesucht und davon 26 verwendet (leider ohne zu sagen, welche 26)</item>
      <item>CFR auf den Evakuierungsfl√ºgen von China nach z.B. Deutschland, Japan und Malaysia (insgesamt 290 F√§lle)</item>
      <item>Aufwuchsrate der Epidemie, also der t√§gliche Zuwachs an neuen F√§llen ‚Äì diese Aufwuchsrate wurde auf Basis der offiziellen Meldungen abgeleitet</item>
      <item>Zeitraum zwischen Infektion und Tod / Erholung</item>
    </list>
    <p><lb/>Damit gibt es folgende Probleme:</p>
    <list>
      <item>Zun√§chst ist die CFR nicht zuverl√§ssig. Sie hatten das so sch√∂n formuliert ‚Äì ‚Äûviele Patienten sterben nicht an COVID-19 sondern mit COVID-19‚Äú. Diese Erkenntnis, die ja auch im Wesentlichen auf der Arbeit von Prof. Schirmacher und seinen Kollegen beruht, hatte man zu diesem Zeitpunkt (Anfang Februar) noch nicht, sondern hat platt angenommen, wer positiv auf COVID getestet wurde und starb, ist an COVID-19 gestorben. Die Todesf√§lle in Hubei betreffen allesamt √§ltere Menschen (nur sechs Opfer sind unter 60 Jahre, der J√ºngste ist 36, wobei nicht klar ist, welche 26 Personen aus dem Datensatz mit 39 Opfern in die Analyse eingeflossen sind). Bereits an diesen fr√ºhen Daten war absehbar, dass √§ltere Menschen deutlich st√§rker betroffen sind als j√ºngere. Das Modell l√§sst das vollkommen unber√ºcksichtigt. Prof. Ioannidis hat bereits fr√ºh auf die mangelnde statistische G√ºte der vorhandenen Daten hingewiesen.</item>
      <item>Es fehlten √ºberall Testkapazit√§ten, daher wurde nicht repr√§sentativ getestet, sondern in der Regel nur beim Vorliegen von (teils schweren) Symptomen und auch erstmal nur in Wuhan, also mit sehr hoher Wahrscheinlichkeit Menschen mit Vorerkrankungen und mit sehr geringer Wahrscheinlichkeit junge, gesunde Menschen ohne Symptome, deren CFR weit geringer ist. Menschen ohne oder mit nur milden Symptomen sind in der Stichprobe aus Hubei vollkommen unterrepr√§sentiert.</item>
      <item>Umgekehrt wurden die ausgew√§hlten Heimkehrerfl√ºge gr√∂√ütenteils vollst√§ndig getestet. Deshalb √ºberwiegen in diesem Datenset die Patienten ohne Symptome (Gesamt 10 F√§lle, davon 7 asymptomatisch). Die Daten sind daher keineswegs vergleichbar.</item>
      <item>Bei den Heimkehrerfl√ºgen war in 50% der F√§lle kein Infektionsdatum bekannt. Neil Ferguson hat daher einfach das Datum des ersten Kontakts mit den Gesundheitsbeh√∂rden angenommen. Dazu schreibt er w√∂rtlich: ‚ÄûWe note this is the latest possbile onset date and may therefore increase our estimates of CFR‚Äù.</item>
      <item>Zudem wurde mit Ausbreitung der Pandemie auch die Testkapazit√§t erh√∂ht, so dass sich die Wahrscheinlichkeit, dass eine bestimmte Bev√∂lkerungsgruppe in der Gruppe aller getesteten repr√§sentiert ist, sich mit der Zeit ‚Äì quasi t√§glich ‚Äì ver√§ndert hat. Die Hypothese, die t√§glich publizierte Zahl der Infizierten, w√ºrde jeden Tag im gleichen linearen Verh√§ltnis zur tats√§chlichen Zahl der Infizierten stehen, ist nicht richtig. Neil Ferguson hat das zwar in der Studie erw√§hnt und auch richtigerweise auf die unterschiedlichen Testkapazit√§ten, -qualit√§t und -praxis in verschiedenen L√§ndern hingewiesen, aber die Relation zwischen Testaufwuchs und gemessenen Infektionen konnte niemand zu diesem Zeitpunkt richtig absch√§tzen.</item>
      <item>Die Aufwuchsrate der Epidemie wurde deutlich √ºbersch√§tzt, denn es wurden ja nicht jeden Tag gleich viele Menschen getestet, sondern jeden Tag mehr, so dass man auch immer mehr Infizierte fand. Der Aufwuchs setzt sich zusammen aus dem Aufwuchs der Testkapazit√§ten und dem Aufwuchs der tats√§chlichen Infektion, ersteres wurde aber zu gering gesch√§tzt.</item>
      <item>F√ºr die Wahrscheinlichkeitsverteilung f√ºr den Verlauf zwischen Infektion und Tod / Genesung wurde die Wahrscheinlichkeitsverteilung der SARS-Epidemie von 2003 in Hong Kong herangezogen und verallgemeinert, so dass der Zeitraum mit 22 Tagen analog zur damaligen SARS-Epidemie angenommen wurde. Auf den ersten Blick erscheint das fragw√ºrdig, denn zum Zeitpunkt der Studie lagen noch keine gesicherten Erkenntnisse vor, dass der Verlauf von COVID-19 dem von SARS entspricht.</item>
    </list>
    <p>Mit dieser recht wackeligen Datenlage und noch wackligeren Annahmen wurde dann mit Hilfe von verschiedenen statistischen Methoden (Bayes Statistik, Maximum-Likelihood, Kaplin-Meier) die CFR berechnet.<lb/>Die hohe Unsicherheit beschreibt Neil Ferguson selbst, denn die ermittelte CFR schwankt in den Gruppen Hubei und den R√ºckfl√ºgen zwischen 1,2% und 18%. Am Ende werden eigentlich nicht zusammen passende Daten miteinander vermischt und eine CFR von ca. 1% mit einem Unsicherheitsintervall von 0,5% bis 4% gesch√§tzt. Zieht man die unbeachteten Fehler (√úbersch√§tzung der Aufwuchsrate, Dunkelziffer bei den Infektionen, Differenzierung bei der Todesursache, etc.) in die Kalkulation mit ein, reduziert sich das weiter.<lb/>Aus handwerklicher Sicht h√§tte das eigentlich niemals publiziert werden d√ºrfen. Die Schwankungen in den Ergebnissen gehen √ºber eine ganze Gr√∂√üenordnung und die Unsicherheit in den Eingangsdaten ist offensichtlich. Es zeigt aber sehr sch√∂n, das Dilemma. Die Wissenschaft konnte im Februar keine klaren Ergebnisse liefern. Es w√§re m√∂glich, dass die CFR bei 18% lag. Genauso konnte sie bei 0,8% oder darunter oder bei jedem anderen Wert liegen. Die Entscheidung war daher eine rein politische. Die Politik wiederrum hat einfach die ‚Äûaus der H√ºfte geschossene‚Äú Todesrate von 1% genommen und durchmultipliziert. Dabei kamen ebenso logisch wie falsch Millionen Tote heraus.<lb/>Man kann an diesem Beispiel wunderbar erkennen, wie gef√§hrlich die mathematische Modellierung sein kann, wenn man die Annahmen nicht gr√ºndlich betrachtet. Ein ehemaliger Chef von mir (alter Controller) hat mal zu mir gesagt: ‚ÄûBusinesscases schaue ich mir nie an. Ich glaube schon, dass die Leute richtig rechnen k√∂nnen. Ich schaue mir immer die Annahmen an. Da l√ºgen sich alle in die Tasche.‚Äú Um in solchen schwerwiegenden und unklaren Situationen eine gute Entscheidung zu treffen, reicht es nicht auf oft fragw√ºrdige Zahlen zu schauen. Es braucht vor allem F√ºhrungsqualit√§ten, wozu auch ein Bauchgef√ºhl und Risikobewusstsein geh√∂ren.<lb/>Der Beitrag erschien zuerst bei ACHGUT hier</p>
  </main>
  <comments>
    <p>&gt;&gt;Bei vielen gestorbenen Covid-19-Patienten k√∂nnen Thrombosen und Embolien festgestellt werden. Das ist das Ergebnis einer Studie am Institut f√ºr Rechtsmedizin des Universit√§tsklinikums Hamburg-Eppendorf (UKE), wie Stefan Kluge, Direktor der UKE-Intensivmedizin am Freitag in Hamburg sagte. Demnach seien bei Obduktionen von zw√∂lf Covid-19-Patienten in sieben F√§llen verst√§rkt Thrombosen ‚Äì also Gerinnselbildungen ‚Äì in den Gef√§√üen der unteren Extremit√§ten festgestellt worden. Vier Patienten seien an einer Lungenembolie gestorben, ohne dass es vor ihrem Tod entsprechende Anzeichen gegeben habe.</p>
    <p>Die Ergebnisse der Studie h√§tten sich auch bei weiteren Obduktionen wiedergefunden, sagte der Direktor des Instituts f√ºr Rechtsmedizin, Klaus P√ºschel. Insgesamt seien in seinem Institut bisher 190 gestorbene Covid-19-Patienten untersucht worden.</p>
    <p>Therapie mit blutverd√ºnnenden Mitteln empfohlen.</p>
    <p>Die Ergebnisse h√§tten auch Einfluss auf die Behandlung Erkrankter, sagte Kluge. ‚ÄûWir haben jetzt die M√∂glichkeit, einen Teil der Patienten zu behandeln mit Blutverd√ºnnern. Und das sollten wir auch tun.‚Äú</p>
    <p>Laut einer Studie des Universit√§tsklinikums Hamburg-Eppendorf hatten viele Corona-Tote Lungenembolien. Der Infektiologe Hans-Peter Hauber von der Asklepios-Klinik Altona im Gespr√§ch.</p>
    <p>Dass in die den Angaben zufolge weltweit erster Studie dieser Art nur vergleichsweise wenig Obduktionen eingingen, sei auch dem Zeitfaktor geschuldet, sagte der Oberarzt des Instituts f√ºr Rechtsmedizin, Jan Sperhake. H√§tte man mehr F√§lle ber√ºcksichtigt, ‚Äûw√§ren wir nicht schnell genug gewesen. So einfach ist das.‚Äú</p>
    <p>Ein weiteres Ergebnis sind h√§ufig festgestellte Nebenerkankungen bei verstorbenen Covid-19-Patienten an Lunge und Herz oder Krankheiten wie Parkinson und Demenz. √úbergewicht und Zuckerkrankheit scheinen laut Sperhake ein Risikofaktor zu sein. Insgesamt weisen die √Ñrzte aber darauf hin, dass weitere Folgeuntersuchungen f√ºr ein besseres Bild n√∂tig sind.&lt;&lt;</p>
    <p>Und damit d√ºrfte klar sein, da√ü die meisten √Ñrzte gepennt haben oder schlimmer noch unf√§hig sind sich selbst gegen Virus√ºbertragungen bei Obduktionen zu sch√ºtzen.</p>
    <p>Wie gut √Ñrzte sind kann man daran erkennen, da√ü die mir etliche Z√§hne ziehen wollten. Bis auf die 4 Weisheitsz√§hne und einen vor einem Eckzahn habe ich noch alle Z√§hne. Das zeigt: Traue niemals einem Arzt. √úberpr√ºfe das, was die machen wollen.</p>
    <p>Wie hei√üt es doch so sch√∂n? Vertrauen ist gut, Kontrolle ist besser!</p>
    <p>Der Disput erinnert mich an die sch√∂nen Zeiten, als es in der Bibliothek des Jenaer ZEISS-Werkes noch keinerlei Literatur zur Programmierung gab und wir Fans einen ReAssembler geschrieben haben, um hinter die Tricks zu schauen, welche die Programmierer des Home-Computers Sinclair ZX81 angewendet haben, um in einem winzigen Chip nicht nur BASIC, sondern auch noch das Betriebssystem mit mehreren wichtigen Schnittstellen zur Au√üenwelt, wie Tastatur, Bildschirm und Tonbandger√§t (zur austauschbaren Aufzeichnung geschriebener Programme in Z80-Assembler u. BASIC) unterzubringen.</p>
    <p>Damals zerfiel diese Welt in die beiden Konkurrenten Sinclair mit dem ZX81 und Commodore mit dem C64, die sich die Ossis von wohlmeinenden Omas und Opas ‚Äû‚Ä¶aus dem Westen‚Ä¶‚Äú mitbringen lie√üen.</p>
    <p>Es hat uns trotzdem nicht daran gehindert, uns auch mit FORTH und Assembler zu befassen und f√ºr den Winzling auch noch ein trickreiches Grafikprogramm zu schreiben (mit 256 x 192 Pixeln), also Punkt-Setzen, Linie-Ziehen, Kreisbogen und Vollkreis mit Stauchungs-Koeffizient f√ºr Ellipsen usw. Echtes Nostalgie-Feeling solche Erinnerungen!</p>
    <p>Herzlichen Dank!</p>
    <p>Meinereiner hatte vor der Wende beide ‚Äì ZX81 und dann C64, wobei eher der ZX Spectrum damals das ‚ÄûGegenst√ºck‚Äú zum C64 war.</p>
    <p>Hier in Ilmenau an der TH gab es schon Jahre vor der Wende (!!!)einen ‚ÄûCommodore-Computer-Club‚Äú (Nutzer anderer ‚ÄûHeimrechner‚Äú waren nat√ºrlich auch sehr willkommen‚Ä¶). Da wurde nicht nur ‚Äûgespielt‚Äú und kopiert, sondern auch ‚ÄûDDR-typische‚Äú Anwendungen ‚Äûgebastelt‚Äú, wie z.B. das Thema, aus einer Typenradschreibmaschine einen ‚ÄûQuasi-Nadeldrucker‚Äú zu machen oder √ºberhaupt an den C64 zu bringen. Selbst √ºber ‚ÄûKI‚Äú auf dem C64 wurde gefachsimpelt ‚Ä¶.</p>
    <p>Ich habe mit meinem C64 ‚ÄûPioniernachmittage‚Äú an unserer (Grund-) Schule gestaltet, wo viele Kinder √ºberhaupt erst mal mit Computern direkt in Ber√ºhrung gekommen sind ((Geschicklichkeitsspiele, Ratespiele ‚Ä¶). Was ich den Kindern einleitend immer gesagt habe: Computer sind eigentlich ganz dumm, erst der Programmierer entscheidet, was der Computer kann oder auch nicht, womit der Bogen zum Fadenthema wieder hergestellt ist.</p>
    <p>Ich bin leider nicht weit √ºber Basicprogrammierung hinaus gekommen, hat aber bis heute f√ºr meine messtechnischen Anwendungen gereicht. Zu DDR-Zeiten hatten wir Messger√§te-Schnittstellen f√ºr den K1002 ‚Äûnachgebastelt‚Äú und jahrelang erfolgreich (bis nach der Wende) betrieben (bis die Magnetkarten nicht mehr funktionierten‚Ä¶). Der Code war sehr ‚Äûmaschinennah‚Äú, aber was wir da mit 2k Programmspeicher ‚Äûangestellt‚Äú haben, daf√ºr w√ºrde man heute einige MB brauchen ‚Ä¶..</p>
    <p>PS: In der DDR wurden Programmiersprachen in MOPS und POPS unterschieden, aber das d√ºrfte Ihnen ja bekannt sein ‚Ä¶ üòâ</p>
    <p>‚ÄûBefore the GitHub team started working on the code it was a single 15k line C file that had been worked on for a decade, and some of the functions looked like they were machine translated from Fortran. There are some tropes about academic code that have grains of truth, but \‚Äú</p>
    <p>https://twitter.com/ID_AA_Carmack/status/1254872369556074496</p>
    <p>Zur Info f√ºr alle Egoshooter-Zocker der ersten Stunde:</p>
    <p>John Carmack entwickelte unter anderem einen Gro√üteil der Game-Engines von Doom und Quake !</p>
    <p>Vers√∂hnt wurde ich dann durch den Nachtrag. Da stand dann endlich, was wir alle schon wussten: Epidemiologische Modelle sind simpel und effizient, das Problem liegt in der Absch√§tzung der Eingabeparameter, was gerade bei einer neuen Krankheit mit gro√üen Unsicherheiten verbunden ist.</p>
    <p>Dass Ferguson da anfangs suboptimal gehandelt hat, ist im Nachhinein leicht festzustellen. Interessant ist, dass es der Klimaforscher James Annan schon sofort gesagt hat und die Eingangsparameter besser bestimmt hat, siehe</p>
    <p>http://julesandjames.blogspot.com/2020/04/blueskiesresearchorguk-model.html</p>
    <p>Und hier sieht man sehr sch√∂n, wie empfindlich die Prognosen auf Ver√§nderungen der Daten reagieren (logarithmische Skala beachten!):</p>
    <p>http://julesandjames.blogspot.com/2020/04/reporting-delays-etc.html</p>
    <p>Die in Gefangenschaft gehaltenen Menschen haben alles l√§ngst durchschaut. Betrachten Sie die wunderbaren, sch√∂nen Bilder vom gestrigen Mittwoch. Es ist alles so wie fr√ºher, wie an jedem warmen, sonnigen Tag, nicht nur am Strand. Man h√§lt keinen Abstand mehr.</p>
    <p>Quelle:</p>
    <p>https://www.dailymail.co.uk/news/article-8341971/PMs-plan-end-lockdown-TEN-DAYS.html</p>
    <p>mir ist nicht klar, inwieweit ihr Beitrag einen Bezug zu meinem Post hat. K√∂nnten Sie das erl√§utern?</p>
    <p>Ich versuche mal einen herzustellen:</p>
    <p>Ihre Bilder zeigen, dass nun eine neue √Ñra anbricht. Wie werden sich dadurch die Eingabeparameter ver√§ndern? Schwer zu sagen, es ist ja eine neuartige Krankheit und es fehlen die Erfahrungen, welchen Einfluss diese Ver√§nderungen z.B. auf die Reproduktionsrate haben werden. Jede Modellierung der Zukunft ist also automatisch nur eine grobe Absch√§tzung.</p>
    <p>Mit Gl√ºck geht alles gut, mit Pech starten wir eine zweite Welle mit einem zweiten Lockdown. In diesem Falle h√§tten wir wohl Probleme damit, die Bilder als ‚Äûwunderbar‚Äú zu bezeichnen.</p>
    <p>Sie sind in ‚ÄûGefangenschaft‚Äú? Mein Beileid, da geht es mir weitaus besser.</p>
    <p>Vielleicht zum Trost ein Kant-Zitat? Freiheit ist die Einsicht in Notwendigkeit.</p>
    <p>‚ÄûUnd hier sieht man sehr sch√∂n, wie empfindlich die Prognosen auf Ver√§nderungen der Daten reagieren [‚Ä¶]‚Äú</p>
    <p>1. Nennen Sie mir (alle) Staaten, die Daten absolut sicher validieren wollen und es auch k√∂nnen. Zur Erinnerung: Keine echte Validierung, keine Wissenschaft m√∂glich.</p>
    <p>2. Der Hamburger Rechtsmediziner Prof. P√ºschel kann das. Er soll bei mittlerweile √ºber 200 Leichen die Obduktion (Autopsie) durchgef√ºhrt haben. Die unf√§hige Regierung ignoriert ihn und seine bemerkenswerten Resultate. Diese Tatsache allein, sollte bei Ihnen die Alarmglocken l√§uten lassen. Wer P√ºschel ignoriert, macht automatisch Pseudo-Wissenschaft, will das Volk betr√ºgen.</p>
    <p>3. Kant? Nein danke. Dann ist mir ein Stoiker lieber.</p>
    <p>‚ÄûDie Krankheit ist ein Hindernis f√ºr den K√∂rper, nicht f√ºr den Willen, sofern dieser es nicht selbst so will.</p>
    <p>Hinken ist ein Hindernis f√ºr das Bein, nicht f√ºr den Willen. Dies sage dir bei allem, was dich trifft. Dann wirst du finden, da√ü die Ereignisse immer ein Hindernis f√ºr etwas bilden, nicht aber f√ºr dich.‚Äú (Epiktet, der Marcus Aurelius beeinflusst haben soll.)</p>
    <p>4. Kant war einf√§ltig und hat die Leute betrogen, sie dumm gemacht. Auch war er in der Freimaurerkirche zum Todtenkopf und der [albernen] Ph√∂nix. Das m√ºssten Sie als Kantianer wissen. Das ist Ihre Pflicht, w√§re es. Und an die Auferstehung einer toten Ph√∂nix glauben zu wollen, ist wirklich das Allerletzte, was ein Mensch brauchen kann. Und einen Totenkopf anbeten? Igitt.</p>
    <p>Stoiker schlagen jeden Kantianer. üòâ</p>
    <p>5. Lesen Sie die anderen Artikel, vor allem auch die vielen klugen Kommentare, dann erkennen auch Sie, der Lockdown war ein sehr teurer und gemeiner Fehler, dieser Regierung in Berlin. Und fahren Sie (zur Not nur gedanklich) nach Taiwan. Die zeigen Ihnen, wie man damit richtig umgeht. Denn, mit Taiwan besch√§ftigt sich kaum einer. Die werden auch ignoriert. Die kommunistisch gef√ºhrte WHO hat Taiwan aus der WHO hinaus bef√∂rdert, weil die kriminellen Rotchinesen das so wollten. In Rotchina gibt es keine freie Meinung, kein freies √∂ffentliches Denken. Demnach wird auch dort keine echte Wissenschaft gedeihen k√∂nnen.</p>
    <p>Die britischen B√ºrger sind weitaus kl√ºger als Merkel und ihre korrupten M√∂chtegern-Wissenschaftler.</p>
    <p>Ich wollte damit nur sagen, andeuten, in Erinnerung rufen, in Assembler zu programmieren ist ungleich schwerer und zeitaufwendiger. Assembler hat noch andere Schwierigkeitsgrade, wie Prozessertyp, Lesbarkeit, tieferes Verst√§ndnis der Materie.</p>
    <p>Ich kann leider keine Assembler-Programmieurng. Hat sich nicht ergeben. Aber, f√ºr den, der sie beherrscht, bieten sich gro√üe Vorteile.</p>
    <p>Auch in C wollen Arrays gelernt sein.</p>
    <p>Mit 30 Jahren Erfahrung sind Sie mir eindeutig √ºberlegen. Gratulation. Da kann ich nur von Ihnen lernen.</p>
    <p>Seine Geliebte ist verheiratet. W√§hrend des Lockdowns trafen sich beide, feierten Party, mit anderen wom√∂glich zusammen, und setzten dem Ehemann die H√∂rner auf, ohne dessen Zustimmung.</p>
    <p>Ferguson hielt sich also selbst nicht an seiner (unfachm√§nnischen) Empfehlung. Das f√ºhrte dann auch zu seiner Entlassung. So las ich es zumindest.</p>
    <p>Ferguson kann auch deshalb kein gro√üer Denker sein, weil er so nebenbei die komplette Wirtschaft eines Landes ruiniert. Kompetenz ist etwas v√∂llig anderes.</p>
    <p>Ferguson war noch nie Taiwan. Sollte er tun.</p>
    <p>Erstens muss ich Herrn Heino M√ºller Recht geben bez√ºglich Fortran. Man kann behaupten, Fortran ist die Mutter aller Programmiersprachen, moderne sehen ganz anders aus und haben viel mehr M√∂glichkeiten, sind aber gewisserma√üen alle Weiterentwicklungen von Fortran.</p>
    <p>Zweitens: ‚Äû‚Ä¶erfolgreich deterministische Modelle, die den Zufallsfaktor ber√ºcksichtigen.‚Äú Es wird dem Leser suggeriert, dass Modelle die Zuf√§lle ber√ºcksichtigen k√∂nnte, die man in der Wirklichkeit nicht im Voraus einbeziehen kann. Das ist riesengro√üer Unfug. Um bei dem Beispiel vom Chirurgen und Herzpatienten zu bleiben: Bei jedem gro√üen Eingriff kann es zum Tod des Patienten kommen, durch Zufall. Egal wie gr√ºndlich die Vorbereitung ist, manchmal stellt sich zum Schlu√ü heraus, der Patient h√§tte ohne der OP paar Monate gelebt, nun ist er tot. Zufall, nicht berechenbar. Zu welchen Thema auch immer, davon auszugehen, dass Computer Programme Zuf√§lle exakt zu vorherzusehen‚Ä¶ So eine Steigerungsform von Dummheit kann ich nicht formulieren.</p>
    <p>Drittens: Es ist ein generations√ºbergreifende und bildungs√ºbergreifende Problem unserer Gesellschaft, dass man i.d.R. Simulationsergebnisse nicht richtig einordnen kann, selbst unter vielen Eike-Lesern.</p>
    <p>Der Klassiker: Wenn ich freudig mitteile, es ist 20 Grad warm, kommt aus der Umgebung h√§ufig ‚Äûmein Handy zeigt aber nur 17 Grad an!‚Äú Es ist ein allgemeines Unverm√∂gen bis Unwillen, zwischen Wirklichkeit (20 gemessen) und Simulation (17 vorhergesagt) zu differenzieren. Habe inzwischen die Lust verloren nachzufragen, welche Art von Thermometer das Handy hat, man erntet nur Unverst√§ndnis. Es wird eben nicht differenziert, beide steht auf ein Display und ist also gleichwertig.</p>
    <p>Den Lesern hier traue ich zu, den Unterschied in diesem Beispiel zu erkennen. Bei komplexeren Simulationen, die man inhaltlich nicht exakt nachvollziehen kann (Beispiel Klima), neigt auch hier wohl die Mehrheit dazu, √ºber gute, schlechte, richtige oder fehlerhafte Simulation zu sprechen, anstatt auf den Punkt zu kommen:</p>
    <p>Jede Simulation zeigt nur Eins von vielen m√∂glichen Ergebnissen. Die Wirklichkeit k√∂nnte nah dran sein, weit weg davon sein, manchmal auch exakt √ºbereinstimmen. Bei den Wettervorhersagen klar zu sehen, bei allen anderen komplexen Simulationen mit vielen Unbekannten und Zuf√§lle ist es nun mal genau so. Es ist nur eine M√∂glichkeit, ob es so kommt oder ganz anders, wei√ü nur der liebe Gott.</p>
    <p>Damit kann eine Simulation unm√∂glich die Grundlage einer weitreichende Entscheidung sein. Wer das tut ist entweder v√∂llig unf√§hig als Entscheider, oder ist ein Betr√ºger, der die Simulation als Ausrede f√ºr seine Entscheidung vorschiebt. Eine Simulation mit welchen Ergebnis auch immer, kann nur eine von vielen Bausteine sein, die zur Entscheidungsfindung f√ºhren. Nicht mehr und nicht weniger.</p>
    <p>Daher ist die Artikel-Aussage: ‚ÄûFalsche Entscheidung, da auf Grundlage einer Simulation in der falschen Sprache getroffen‚Äú mehrfach inhaltlich absoluter Unsinn.</p>
    <p>Komme zum Klima zur√ºck und erneuere mein Angebot: gebt mit genug Geld und Zeit und ich erschaffe eine Klimasimulation die f√ºr das Jahr 2100 die Temperatur ihrer Wahl vorhersagt, in der Spanne von plus minus 5 gem√§√ü heute. Habe von Programmierung keine Ahnung, war aber lange genug Schnittstelle zwischen Kunde und Developer bei komplexen Berechnungen. Es wird so lange getrimmt, bis der Kundenwunsch erf√ºllt ist. Beim einer Klimasimulation w√ºrde ich zuerst den Programmierern vorschlagen, den CO2 Einflu√ü auf fast Null zu reduzieren und den Sonneneinflu√ü zu erh√∂hen und entsprechende Schwankungen der Sonne einzubauen‚Ä¶</p>
    <p>Woher k√∂nnte jemand exakt feststellen, dass ‚Äûmeine Methode‚Äú falscher sei als die von Ramstorf und Konsorten?</p>
    <p>Nur mal so um den Glauben an heiligen Simulationen ein wenig zu ersch√ºttern!</p>
    <p>Die Kritik ist berechtigt. Es kommt nicht auf die Programmiersprache an, sondern wie man sie nutzt.</p>
    <p>Die Kritik ist berechtigt. Es kommt nicht auf die Programmiersprache an, sondern wie man sie nutzt.</p>
    <p>Der Artikel wurde am 19.M√§rz verfasst. Die Modellrechnung basiert auf bekannten Daten vor diesem Datum. Erst danach wurde der ‚ÄûShutdown‚Äú in England eingef√ºhrt. Wenn die damaligen Projektionen die Fallzahlen √ºbersch√§tzt haben ist dies nicht ein Fehler des Codes, sondern ein Beweis f√ºr die Wirksamkeit des Shutdowns.</p>
    <p>https://www.deutsche-apotheker-zeitung.de/news/artikel/2020/04/06/shutdown-duerfte-bereits-zehntausende-tote-in-europa-verhindert-haben</p>
    <p>Sie haben das Pandemie-Problem nicht verstanden. Ich verwende folgenden einfachen Ansatz. NA(t) ist die Zahl der aktiv infizierten, N0(t) die Anzahl der nicht infizierten und und nicht immunen lebenden Individuen. Dann gilt f√ºr die Wachstumsrate der aktiv infizierten Individuen dNA(t)= r(t)*NA(t)*N0(t). Der Koeffizient r(t) wird bestimmt durch (1) durch das Individuum selbst, (2) durch die Gebiets-Strukturen (Bev√∂lkerungsdichte, Sozialverhalten usw.), (3) durch staatliche Eingriffe. Schweden kam ohne staatliche Eingriffe aus. Der Einfluss der staatlichen Eingriffe in Frankreich und in Deutschland ergibt sich wohl erst aus einer genaueren Analyse des Verlaufs der Fall-Zahlen.</p>
    <p>verwenden Sie f√ºr die Zahl der aktiv Infizierten absolute Zahlen oder ber√ºcksichtigen Sie das Verh√§ltnis zwischen Infizierten und Anzahl der durchgef√ºhrten Tests? Und was die Wirksamkeit der Ma√ünahmen angeht, kann man auf Euromomo sehr sch√∂n sehen, dass es keine Korrelation zwischen Zeitpunkt sowie Art der Ma√ünahmen und der √úbersterblichkeit gibt. Zur Problematik der absoluten Fallzahlen noch etwas Interessantes:</p>
    <p>https://www.heise.de/tp/features/Die-Ueberschaetzung-des-tatsaechlichen-Anstiegs-der-Coronavirus-Neuinfektionen-4709977.html</p>
    <p>Zustimmung. Kann man so sehen, kann man so verteidigen.</p>
    <p>Ich habe mich selbst bereits mit Fortran besch√§ftigt, einige Zeilen nachprogrammiert und h√§tte gerne mehr Zeit darin investiert. Es gibt ‚Äûgef√ºhlt‚Äú zig Varianten von Fortran. Oder zuviele davon.</p>
    <p>F√ºr ein Virus und derem Verlauf d√ºrfte Fortran aber nicht die beste Wahl sein, sondern unn√∂tig kompliziert. Wie Sie selbst andeuten, mu√ü man das Programmieren sehr gut beherrschen, um Fortran zu verwenden. Es gibt aber nicht so viele gute Programmierer.</p>
    <p>Fortran wurde entwickelt, zu einer Zeit, in der man noch mit Lochkarten arbeitete. Daher ist das Schreiben von Fortran-Programmen am Lochkartenformat orientiert. Zus√§tzlich ist jede Programmzeile in vier Bereiche eingeteilt. Zumindest bei der klassischen Fortran-Variante.</p>
    <p>Fortran wurde bereits 1955 erfunden, bei IBM. Da gab es den Begriff ‚Äûcomputer scientist‚Äú noch gar nicht.</p>
    <p>Was f√ºr Fortran spricht, ist seine sehr viel h√∂here Schnelligkeit. Die auch heutige High-Level-Sprachen √ºbertreffen soll, so Kupferschmidt im Jahr 2002.</p>
    <p>Fortran ist weiterhin die Sprache (der Wahl) f√ºr Ingenierue, die Berechnungen durchf√ºhren wollen, m√ºssen, die nicht allt√§glich sind, nicht standardisierbar, f√ºr die noch keine Software programmiert wurde. Vor allem f√ºr Numerische Verfahren, nicht-lineare Gleichungssysteme. Und so fort.</p>
    <p>Also, ich finde Fortran eine sehr interessante Sprache. Ob f√ºr die Kalkulation eines Virus so ein Riesenaufwand notwendig sein soll, das bezweifle ich sehr. Ein Mathebuch und etwas Papier h√§tten auch gereicht. Keine Programmierung der Welt kann intensives Nachdenken, Reflektieren ersetzen. Das verstehen vor allem Linke nicht.</p>
    <p>Danke, haben wir √ºbernommen. Die Kritik ist berechtigt. Es kommt nicht auf die Programmiersprache an, sondern wie man sie nutzt.</p>
    <p>So sehr ich die Beitr√§ge auf AchGut sch√§tze, lest bitte die Kommentare, bevor Ihr einen dort erschienen Beitrag ‚Äûnachdruckt‚Äú. Die Aussage der zitierten IT Experten sind inhaltlich als fortgeschritten d√ºmmlich zu bezeichnen. Ich will jetzt meinen Verri√ü vom AchGut Artikel nicht wiederholen. Aber, es gilt nach wie vor : garbage in, garbage out. FORTRAN ist eine Sprache aus dem technischen Bereich. Nat√ºrlich gibt es heute Entwicklungssysteme, die komfortabler zu bedienen sind. Wenn aber die Simulation die Wirklichkeit nicht abbildet (siehe Klimasimulationen GW!!!!!!!!), dann liegt das am L√∂sungsdesign, nicht an der Programmiersprache!</p>
    <p>Also die Programmiersprache hat letztendlich nichts mit der Qualit√§t eines Ergebnisses zu tun, sondern nur das Wissen und K√∂nnen des Programmierers.</p>
    <p>Dann programmieren Sie doch mal das Gleiche in Assembler. Auch eine Programmiersprache.</p>
    <p>Fortran does one thing (much better and easier) that C does not do: math.</p>
    <p>In C programmieren, ist gleichbedeutend, mit einem Porsche zu fahren und in ein offenes Messer zu greifen.</p>
    <p>Wieso gibt es dann so unglaublich viele Programmiersprachen? Wohl, weil jede √ºber gewisse Vorteile verf√ºgen darf.</p>
    <p>Manche Programmiersprachen provozieren leichter gewisse Fehler. Niemand ist frei von Denkfehlern. F√ºr die ist der Mensch allein verantwortlich. Oder nehmen Sie das Thema Arrays. Auch ein Kapitel f√ºr sich. In manchen Sprachen schwieriger, folglich fehleranf√§lliger. Und Arrays sind wichtig. Wenn man mit gro√üen Datenmengen zu tun hat. Vor allem dann.</p>
    <p>Die Wahl der Programmiersprache entscheidet √ºber, ist eine Funktion, der H√§ufung der Programmierfehler. Au√üerdem gilt knallhart: mit steigender Zahl an Codezeilen, steigen auch die Programmierfehler. Und wie!! Manche Sprachen beg√ºnstigen Fehler leichter als andere. Eine Binsenweisheit.</p>
    <p>Fortran ist eine Programmiersprache, mit deren Hilfe ein Wissenschaftler oder auch Ingenieur Anweisungen formuliert (Code), die √ºber den zugeh√∂rigen Compiler dem Rechenwerk des Computers vermittelt, was es ausrechnen soll. Das tut Fortran weitestgehend fehlerfrei. Das Problem fehlerhaften Arbeitens liegt fast immer beim programmierenden Wissenschaftler, der sich bem√ºht, (nat√ºrliche) Vorg√§nge in ein numerisches Verfahren zu gie√üen, welches letztlich vom Compiler in ein digitales Zahlenspiel √ºbersetzt wird.</p>
    <p>Fortran ist in vielen Bereichen noch immer die Programmiersprache der Wahl, aber wird leider kaum noch an Universit√§ten gelehrt.</p>
    <p>Was nun genau am Covid-Computer-Modell des Imperial College faul ist, wird hier nicht dargelegt. Es ist mit Sicherheit nicht die Wahl der Programmiersprache.</p>
    <p>Ich ‚Äûbefehle‚Äú Ihnen, von nun an, nur noch in Assembler zu programmieren.</p>
    <p>Danach werden Sie so einen Kommentar (hoffentlich) nie wieder von sich geben.</p>
    <p>Jeder Programmierer macht in jeder Programmiersprache auf jeder Systemplattform irgendwelche Fehler ‚Ä¶ das war immer so und wird so bleiben. Reduzieren l√§√üt sich das nur durch Testen ‚Äì Pr√ºfen -Testen ‚Äì Pr√ºfen ‚Äì Testen ‚Ä¶ usw. ‚Ä¶ was bei umfangreichen wissenschaftlichen Rechenmodellen / Prognosen / ‚Äûmit der Hand am Arm‚Äú schon schwierig ist.</p>
    <p>Mit wachsender Anzahl von variablen Parametern und der Datenmenge w√§chst das Problem ‚Ä¶</p>
    <p>Aber: Wenn das Konzept schon fehlerhaft ist und dann noch unschl√ºssige Daten einflie√üen gilt das immer noch g√ºltige Grundprinzip ‚Äì Mist rein = Mist raus üôÇ</p>
    <p>Bitte hier nur unter vollem Klarnamen posten, siehe Regeln.</p>
    <p>Ich stimme Ihnen zu. Man kann selbstverst√§ndlich auch andere Programmiersprachen benutzen. Fortran ist sehr alt, was aber nicht dagegen spricht, es zu benutzen.</p>
    <p>Die Kritik ist berechtigt. Es kommt nicht auf die Programmiersprache an, sondern wie man sie nutzt.</p>
  </comments>
</doc>