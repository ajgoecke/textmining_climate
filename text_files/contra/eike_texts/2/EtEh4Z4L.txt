Das Urteil der IT-Fachleute ist verheerend: Es handele sich womÃ¶glich um den zerstÃ¶rerischten Softwarefehler aller Zeiten, was die wirtschaftlichen Kosten und die Zahl der verlorenen Leben anbetreffe. Beachten Sie bitte den Nachtrag/ die Aktualisierung am Ende des Textes-
Erinnern Sie sich noch an die Modellrechnung des britischen Wissenschaftlers des Imperial College in London, Neil Ferguson, der die Regierung in Sachen Corona beriet und die wissenschaftliche Grundlage fÃ¼r die strengen AusgangsbeschrÃ¤nkungen in GroÃŸbritannien lieferte? Er prognostizierte 2,2 Millionen Coronatote fÃ¼r die USA und 500.000 fÃ¼r GroÃŸbritannien. Auf diesem Modell beruhte letztlich die Corona-Strategie der Abflachung der Kurve â€flattening the curveâ€œ durch Social Distancing und Lockdown.
Heute erweist sich dieses Modell als hysterische ÃœberschÃ¤tzung. Selbst die vielen Coronatoten in GroÃŸbritannien (ich mÃ¶chte stets anfÃ¼gen, dass diese Coronatoten auch die sehr wahrscheinlich hohe Zahl an Verstorbenen beinhalten, die unnÃ¶tig intubiert wurden), werden bei weitem nicht die vorderen RÃ¤nge der jÃ¤hrlichen Todesursachenstatistik einnehmen, mit oder ohne Lockdown.
Gescheiterte Venus-Raumsonde
David Richards und Konstantin Boudnik, GrÃ¼nder, CEO sowie Sotfwareleiter von WANdisco bezeichnen diese Modellrechnung nun als den womÃ¶glich zerstÃ¶rerischsten Softwarefehler aller Zeiten:
â€Die Modellierung nicht-pharmazeutischer Interventionen fÃ¼r Covid-19 durch das Imperial College, die dazu beitrug, GroÃŸbritannien und andere LÃ¤nder zu drakonischen Lockdowns zu bewegen, wird die gescheiterte Venus-Raumsonde ablÃ¶sen, die als der verheerendste Softwarefehler aller Zeiten in die Geschichte eingehen kÃ¶nnte, was die wirtschaftlichen Kosten und die Zahl der verlorenen Leben betrifft.â€œ
Original auf Englisch heiÃŸt es:
â€Imperial Collegeâ€™s modelling of non-pharmaceutical interventions for Covid-19 which helped persuade the UK and other countries to bring in draconian lockdowns will supersede the failed Venus space probe could go down in history as the most devastating software mistake of all time, in terms of economic costs and lives lost.â€
Im britischen Telegraph fragen die beiden anerkannten Programmier-Spezialisten, warum die Regierung keine zweite Meinung eingeholt hat, bevor sie das Covid-Computer-Modell des Imperial College akzeptiert hat. Weiter schreiben Sie:
â€Seit der VerÃ¶ffentlichung des Mikrosimulationsmodells von Imperial haben diejenigen von uns, die ein berufliches und persÃ¶nliches Interesse an der Softwareentwicklung haben, den Code studiert, auf dem die politischen EntscheidungstrÃ¤ger ihre schicksalhafte Entscheidung basierten, unsere mehrere Billionen Pfund schwere Wirtschaft einzumotten und Millionen von Menschen in Armut und Not zu stÃ¼rzen. Und wir waren zutiefst beunruhigt Ã¼ber das, was wir entdeckt haben. Das Modell scheint vÃ¶llig unzuverlÃ¤ssig zu sein, und Sie wÃ¼rden nicht Ihr Leben darauf verwetten.â€œ
Schon vor 20 Jahren Schnee von gestern
Das Modell von Imperial scheine auf einer Programmiersprache namens Fortran zu basieren, die schon vor 20 Jahren Schnee von gestern gewesen sei. Ihr Code sei auch fÃ¼r die gescheiterte Raumsonden-Mission verwendet worden, wie fÃ¼r die Raumsonde Mariner 1. Und sie sagen: â€In unserer kommerziellen RealitÃ¤t wÃ¼rden wir jeden fÃ¼r die Entwicklung eines solchen Codes feuern, und jedes Unternehmen, das sich bei der Herstellung von Software zum Verkauf darauf verlÃ¤sst, wÃ¼rde wahrscheinlich pleite gehenâ€œ.
Weiter schreiben Sie: Die Modelle mÃ¼ssten in der Lage sein, den grundlegenden wissenschaftlichen Test zu bestehen, um bei gleichen Ausgangsparametern die gleichen Ergebnisse zu erzielen. Andernfalls gibt es einfach keine MÃ¶glichkeit, zu wissen, ob sie zuverlÃ¤ssig sein werden.
Das Resumee der beiden Kritiker: â€TatsÃ¤chlich verwenden viele globale Industrien erfolgreich deterministische Modelle, die den Zufallsfaktor berÃ¼cksichtigen. Kein Chirurg wÃ¼rde einen Herzschrittmacher bei einem Herzpatienten einsetzen, wenn er wÃ¼sste, dass er auf einem wohl unvorhersehbaren Ansatz beruht, aus Angst, den hippokratischen Eid zu gefÃ¤hrden. Warum um alles in der Welt wÃ¼rde die Regierung ihr Vertrauen darauf setzen, wenn das gesamte Wohlergehen unserer Nation auf dem Spiel steht?â€œ
Nachtrag vom 20.Mai 2020
Mein letzter Beitrag wurde in den Leserbriefen zur Recht kritisiert, weil ich mich eben fachfremd bin bzgl. Computer Modellen. Leser Daniel Hirsch hat das ganze Problem mit dem Imperial Model viel besser und treffender erklÃ¤rt. Imperial Model, Computersprache und Schuster bleib bei deinen Leisten. Beim letzten Beitrag, habe ich mein Fachgebiet verlassen, und einige Leser erweiterten daraufhin meinen Horizont. Zu Recht, denn ich werfe es beispielsweise Prof. Christian Drosten vor, dass er sich ausserhalb seiner Fachkompetenz z.B. zur Epidemiologie Ã¤ussert und genau deswegen scheitert. Ein Virologe muss vor den Gefahren warnen, aber Epidemiologie bedeutet gerade eben nicht, stets vom worst case auszugehen, sondern sich um echte Daten zu kÃ¼mmern und diese im Sinne von Wahrscheinlichkeiten zu deuten. Daniel Hirsch ist Computerfachmann und kann die Problematik des Imperial Models deshalb viel treffender beschreiben. Ich mÃ¶chte Ihnen mit seiner Erlaubnis seine Zuschrift an mich nicht vorenthalten:
Als Mathematiker mit der Spezialisierung numerische Mathematik habe ich wÃ¤hrend meines Studiums an der Uni Heidelberg zahlreiche Supercomputer entworfen, betrieben und eigene Modelle entwickelt (mit Schwerpunkt in der nichtlinearen Optimierung und im Bereich unstetige Galerkin-Verfahren). Deshalb mÃ¶chte ich gern die Gelegenheit nutzen und ein bisschen von meiner Expertise beitragen.
1. Programmiersprache
Die Programmiersprache ist letztlich nur eine Form um Maschinensprache (die sprichwÃ¶rtlichen â€bits and bytesâ€œ) fÃ¼r den Menschen lesbar bzw. menschliches strukturiertes Denken fÃ¼r den Computer ausfÃ¼hrbar zu machen. Die Programmiersprachen sind dabei in ihren Grundfunktionen gleich. In jeder Sprache finden sich einfache Strukturen, wie Schleifen (ZÃ¤hlschleife: â€mache irgendwas n malâ€œ; vorprÃ¼fende Schleife: â€so lange eine Bedingung erfÃ¼llt ist, mache irgendwasâ€œ; nachprÃ¼fende Schleife: â€wenn irgendeine Bedingung richtig ist, mache das, was Du vorher gemacht hast nochmalâ€œ), Bedingungen (â€wenn irgendwas richtig ist, mache folgendes, anderenfalls was anderesâ€œ), Zugriffe auf Dateisysteme oder auf den Monitor/Tastatur. Zudem gibt es inzwischen in vielen Programmiersprachen auch die MÃ¶glichkeit komplexere Strukturen, wie z.B. vererbbare Objekte, Templates, etc. zu bauen. Das im Detail auszuleuchten sprengt den Rahmen.
Fortran ist in der Tat eine recht alte Programmiersprache (von 1957), die ihre Vor- und Nachteile hat. Das zu diskutieren lÃ¶st in aller Regel â€“ wie so oft in der IT â€“ einen Glaubenskampf aus. Die Unterschiede in den Programmiersprachen liegen neben der offensichtlichen anderen Syntax in der Regel eine Ebene tiefer, also wie performant ein Compiler ist, wie performant das erzeugte binary ist, wie gut der Code auf andere Plattformen Ã¼bertragen werden kann, etc. Es spielt aber auch eine Rolle, wie stark die Kommerzialisierung einer Programmiersprache ist. Programmiersprachen, die fÃ¼r kommerzielle Software verwendet werden, sind oft stÃ¤rker unterstÃ¼tzt und entwickeln sich schneller als weniger populÃ¤re Sprachen. Die wesentlichen Vorteile von Fortran aus meiner persÃ¶nlichen Sicht sind, dass die Lernkurve um Fortran programmieren zu kÃ¶nnen, recht flach und kurz ist und sehr viel frei verfÃ¼gbarer Code existiert. Es gibt Literatur, wonach gute Fortran Compiler bei Array-basierten Anwendungen schnelleren Code als flexiblere Sprachen wie z.B. C++ produzieren kÃ¶nnen sollen. Das lÃ¤ÃŸt sich in der Regel aber mit â€besseremâ€œ Code kompensieren. Richtig ist in jedem Fall, dass gerade im universitÃ¤ren Bereich Fortran weite Verbreitung hat und es eine lebendige Community gibt, die die vorhandenen Compiler und den Standard (zuletzt 2018) weiterentwickelt. Es ist daher nicht ungewÃ¶hnlich Programme in Fortran in diesem Umfeld zu finden.
2. UniversitÃ¤re Softwareentwicklung
In Mathematik und Physik ist es weit verbreitet Software fÃ¼r verschiedene Zwecke zu entwickeln. Oft wird die Software fÃ¼r eine bestimmte Klasse GroÃŸrechner (z.B. Parallelrechner) oder gar nur fÃ¼r einen ganz bestimmten Rechner entwickelt. Im Vordergrund steht dabei immer die Mathematik oder die Physik und weniger die informatische QualitÃ¤t der Implementierung. Da es ein recht groÃŸer Aufwand ist, jedes Einzelproblem, welches man lÃ¶sen mÃ¶chte, dediziert zu programmieren, verwendet man den Code in sogenannten Bibliotheken immer wieder. Darin sind mathematische Formen, wie Vektoren, Tensoren, Gitter, etc. ebenso wie die mathematischen Modelle und Algorithmen, die mit diesen Strukturen umgehen mÃ¼ssen, bereits implementiert. Diese Bibliotheken werden dann â€“ meist kostenlos â€“ allen anderen Wissenschaftlern zur VerfÃ¼gung gestellt. Die Entwicklungsteams sind klein und es wird nicht nach kommerziellen Standards entwickelt. Man kann nicht erwarten, dass die Software einem IT-QualitÃ¤tsassessment standhalten wird. Daraus zu folgern, dass die Software falsch rechnet, ist jedoch voreilig.
3. Mathematische Modellierung
Wenn ein Modell aufgestellt wird, bedient man sich fÃ¼r gewÃ¶hnlich zunÃ¤chst der Mathematik und zwar ganz klassisch mit Tafel und Kreide. Die Implementierung erfolgt danach mit Hilfe der vorhandenen Bibliotheken. Wenn das Modell implementiert ist, verwendet man Ã¼blicherweise Testdaten und -probleme um zu zeigen, dass die Software funktioniert. Oft werden die Ergebnisse auch publiziert, da neue Modelle / Algorithmen in der Regel nur dann implementiert werden, wenn sie aus wissenschaftlicher Sicht neu sind oder wenn die Implementierung aus irgendeinem Grund besser ist als bisherige Implementierungen (z.B. schnellere Konvergenz, geringerer notwendiger Speicherplatz, hÃ¶here Genauigkeit, etc.). Andernfalls macht sich keiner die MÃ¼he vorhandene Modelle nochmal zu implementieren â€“ auÃŸer vielleicht im Rahmen einer Ãœbung zu einer Vorlesung. Hier liegt auch der Unterschied zur Venus-Sonde. Die Software fÃ¼r die Venussonde war fÃ¼r eine einmalige Anwendung gedacht (nÃ¤mlich genau diese Sonde auf dieser Mission) und konnte unter Echtbedingungen nie getestet werden. Die Modelle von Neil Ferguson sind mehrfach getestet und mit anderen Modellen gegen gerechnet worden. Das schlieÃŸt Programmierfehler freilich nicht aus, aber bisher gibt es keinen Hinweis auf einen solchen. Wahrscheinlicher sind Fehler in den Ausgangsdaten.
4. Numerischer Fehler
Das grÃ¶ÃŸte Problem bei mathematischen Modellen ist der sogenannte numerische Fehler. Die meisten Strukturen in der alltÃ¤glichen Mathematik basieren auf den reellen Zahlen. Ohne die reellen Zahlen funktioniert unsere Welt nicht mehr. Bestes Beispiel: Der Umfang eines Kreises. Ohne die Zahl pi, ist der Umfang nicht exakt zu errechnen. Dummerweise hat pi unendlich viele Nachkommastellen (die wir logischerweise auch nicht alle kennen). Daher kann man eine solche Zahl nicht auf einem Computer abbilden, der ja nur Ã¼ber endlich viel Speicher verfÃ¼gt, selbst wenn wir alle Nachkommastellen kennen wÃ¼rden. Man behilft sich durch Runden der Zahl (typischerweise auf 16 Stellen) . FÃ¼r alltÃ¤gliche Probleme reicht die Rundungslogik auf normalen Rechnern vÃ¶llig aus. Allerdings gibt es noch ein weiteres Problem: Ein mathematisches Modell besteht aus sehr vielen Einzeloperationen. Die Rechenoperationen reagieren dabei unterschiedlich gut auf die Eingangsdaten und die Einzelfehler jeder Operation kÃ¶nnen sich im gesamten Modell aufschaukeln. Es ist daher sehr wichtig, die StabilitÃ¤t/ZuverlÃ¤ssigkeit des Algorithmus gegen derartige Effekte zu kennen.
5. Eingangsfehler
Bei allen Algorithmen gilt das â€shit-in-shit-outâ€œ-Prinzip. Arbeitet man mit Daten, die einen groÃŸen Fehler beinhalten, dann kommt am Ende ein noch viel grÃ¶ÃŸerer Fehler raus (wie viel schlimmer sagt uns die StabilitÃ¤t eines Modells). Die Programmiersprache ist nicht entscheidend, denn es kommt Ã¼berhaupt nicht darauf an, ob ein mathematisches Modell in Fortran, C++, Basic oder von mir aus auf Lochkarten implementiert wird. Genauso wenig wie es darauf ankommen sollte, ob man eine Addition mit dem Rechenschieber, dem Abakus, einem Taschenrechner oder im Kopf durchfÃ¼hrt. Ich bin davon Ã¼berzeugt, dass das Problem des Modells von Neil Ferguson in den Eingangsdaten liegt. Das von ihm verwendete Modell basiert im Wesentlichen auf folgenden Daten:
- Todesrate (CFR) in Hubei â€“ hierzu hat sich Neil Ferguson 39 TodesfÃ¤lle von diversen Webseiten zusammen gesucht und davon 26 verwendet (leider ohne zu sagen, welche 26)
- CFR auf den EvakuierungsflÃ¼gen von China nach z.B. Deutschland, Japan und Malaysia (insgesamt 290 FÃ¤lle)
- Aufwuchsrate der Epidemie, also der tÃ¤gliche Zuwachs an neuen FÃ¤llen â€“ diese Aufwuchsrate wurde auf Basis der offiziellen Meldungen abgeleitet
- Zeitraum zwischen Infektion und Tod / Erholung
Damit gibt es folgende Probleme:
- ZunÃ¤chst ist die CFR nicht zuverlÃ¤ssig. Sie hatten das so schÃ¶n formuliert â€“ â€viele Patienten sterben nicht an COVID-19 sondern mit COVID-19â€œ. Diese Erkenntnis, die ja auch im Wesentlichen auf der Arbeit von Prof. Schirmacher und seinen Kollegen beruht, hatte man zu diesem Zeitpunkt (Anfang Februar) noch nicht, sondern hat platt angenommen, wer positiv auf COVID getestet wurde und starb, ist an COVID-19 gestorben. Die TodesfÃ¤lle in Hubei betreffen allesamt Ã¤ltere Menschen (nur sechs Opfer sind unter 60 Jahre, der JÃ¼ngste ist 36, wobei nicht klar ist, welche 26 Personen aus dem Datensatz mit 39 Opfern in die Analyse eingeflossen sind). Bereits an diesen frÃ¼hen Daten war absehbar, dass Ã¤ltere Menschen deutlich stÃ¤rker betroffen sind als jÃ¼ngere. Das Modell lÃ¤sst das vollkommen unberÃ¼cksichtigt. Prof. Ioannidis hat bereits frÃ¼h auf die mangelnde statistische GÃ¼te der vorhandenen Daten hingewiesen.
- Es fehlten Ã¼berall TestkapazitÃ¤ten, daher wurde nicht reprÃ¤sentativ getestet, sondern in der Regel nur beim Vorliegen von (teils schweren) Symptomen und auch erstmal nur in Wuhan, also mit sehr hoher Wahrscheinlichkeit Menschen mit Vorerkrankungen und mit sehr geringer Wahrscheinlichkeit junge, gesunde Menschen ohne Symptome, deren CFR weit geringer ist. Menschen ohne oder mit nur milden Symptomen sind in der Stichprobe aus Hubei vollkommen unterreprÃ¤sentiert.
- Umgekehrt wurden die ausgewÃ¤hlten HeimkehrerflÃ¼ge grÃ¶ÃŸtenteils vollstÃ¤ndig getestet. Deshalb Ã¼berwiegen in diesem Datenset die Patienten ohne Symptome (Gesamt 10 FÃ¤lle, davon 7 asymptomatisch). Die Daten sind daher keineswegs vergleichbar.
- Bei den HeimkehrerflÃ¼gen war in 50% der FÃ¤lle kein Infektionsdatum bekannt. Neil Ferguson hat daher einfach das Datum des ersten Kontakts mit den GesundheitsbehÃ¶rden angenommen. Dazu schreibt er wÃ¶rtlich: â€We note this is the latest possbile onset date and may therefore increase our estimates of CFRâ€.
- Zudem wurde mit Ausbreitung der Pandemie auch die TestkapazitÃ¤t erhÃ¶ht, so dass sich die Wahrscheinlichkeit, dass eine bestimmte BevÃ¶lkerungsgruppe in der Gruppe aller getesteten reprÃ¤sentiert ist, sich mit der Zeit â€“ quasi tÃ¤glich â€“ verÃ¤ndert hat. Die Hypothese, die tÃ¤glich publizierte Zahl der Infizierten, wÃ¼rde jeden Tag im gleichen linearen VerhÃ¤ltnis zur tatsÃ¤chlichen Zahl der Infizierten stehen, ist nicht richtig. Neil Ferguson hat das zwar in der Studie erwÃ¤hnt und auch richtigerweise auf die unterschiedlichen TestkapazitÃ¤ten, -qualitÃ¤t und -praxis in verschiedenen LÃ¤ndern hingewiesen, aber die Relation zwischen Testaufwuchs und gemessenen Infektionen konnte niemand zu diesem Zeitpunkt richtig abschÃ¤tzen.
- Die Aufwuchsrate der Epidemie wurde deutlich Ã¼berschÃ¤tzt, denn es wurden ja nicht jeden Tag gleich viele Menschen getestet, sondern jeden Tag mehr, so dass man auch immer mehr Infizierte fand. Der Aufwuchs setzt sich zusammen aus dem Aufwuchs der TestkapazitÃ¤ten und dem Aufwuchs der tatsÃ¤chlichen Infektion, ersteres wurde aber zu gering geschÃ¤tzt.
- FÃ¼r die Wahrscheinlichkeitsverteilung fÃ¼r den Verlauf zwischen Infektion und Tod / Genesung wurde die Wahrscheinlichkeitsverteilung der SARS-Epidemie von 2003 in Hong Kong herangezogen und verallgemeinert, so dass der Zeitraum mit 22 Tagen analog zur damaligen SARS-Epidemie angenommen wurde. Auf den ersten Blick erscheint das fragwÃ¼rdig, denn zum Zeitpunkt der Studie lagen noch keine gesicherten Erkenntnisse vor, dass der Verlauf von COVID-19 dem von SARS entspricht.
Mit dieser recht wackeligen Datenlage und noch wackligeren Annahmen wurde dann mit Hilfe von verschiedenen statistischen Methoden (Bayes Statistik, Maximum-Likelihood, Kaplin-Meier) die CFR berechnet.
Die hohe Unsicherheit beschreibt Neil Ferguson selbst, denn die ermittelte CFR schwankt in den Gruppen Hubei und den RÃ¼ckflÃ¼gen zwischen 1,2% und 18%. Am Ende werden eigentlich nicht zusammen passende Daten miteinander vermischt und eine CFR von ca. 1% mit einem Unsicherheitsintervall von 0,5% bis 4% geschÃ¤tzt. Zieht man die unbeachteten Fehler (ÃœberschÃ¤tzung der Aufwuchsrate, Dunkelziffer bei den Infektionen, Differenzierung bei der Todesursache, etc.) in die Kalkulation mit ein, reduziert sich das weiter.
Aus handwerklicher Sicht hÃ¤tte das eigentlich niemals publiziert werden dÃ¼rfen. Die Schwankungen in den Ergebnissen gehen Ã¼ber eine ganze GrÃ¶ÃŸenordnung und die Unsicherheit in den Eingangsdaten ist offensichtlich. Es zeigt aber sehr schÃ¶n, das Dilemma. Die Wissenschaft konnte im Februar keine klaren Ergebnisse liefern. Es wÃ¤re mÃ¶glich, dass die CFR bei 18% lag. Genauso konnte sie bei 0,8% oder darunter oder bei jedem anderen Wert liegen. Die Entscheidung war daher eine rein politische. Die Politik wiederrum hat einfach die â€aus der HÃ¼fte geschosseneâ€œ Todesrate von 1% genommen und durchmultipliziert. Dabei kamen ebenso logisch wie falsch Millionen Tote heraus.
Man kann an diesem Beispiel wunderbar erkennen, wie gefÃ¤hrlich die mathematische Modellierung sein kann, wenn man die Annahmen nicht grÃ¼ndlich betrachtet. Ein ehemaliger Chef von mir (alter Controller) hat mal zu mir gesagt: â€Businesscases schaue ich mir nie an. Ich glaube schon, dass die Leute richtig rechnen kÃ¶nnen. Ich schaue mir immer die Annahmen an. Da lÃ¼gen sich alle in die Tasche.â€œ Um in solchen schwerwiegenden und unklaren Situationen eine gute Entscheidung zu treffen, reicht es nicht auf oft fragwÃ¼rdige Zahlen zu schauen. Es braucht vor allem FÃ¼hrungsqualitÃ¤ten, wozu auch ein BauchgefÃ¼hl und Risikobewusstsein gehÃ¶ren.
Der Beitrag erschien zuerst bei ACHGUT hier
>>Bei vielen gestorbenen Covid-19-Patienten kÃ¶nnen Thrombosen und Embolien festgestellt werden. Das ist das Ergebnis einer Studie am Institut fÃ¼r Rechtsmedizin des UniversitÃ¤tsklinikums Hamburg-Eppendorf (UKE), wie Stefan Kluge, Direktor der UKE-Intensivmedizin am Freitag in Hamburg sagte. Demnach seien bei Obduktionen von zwÃ¶lf Covid-19-Patienten in sieben FÃ¤llen verstÃ¤rkt Thrombosen â€“ also Gerinnselbildungen â€“ in den GefÃ¤ÃŸen der unteren ExtremitÃ¤ten festgestellt worden. Vier Patienten seien an einer Lungenembolie gestorben, ohne dass es vor ihrem Tod entsprechende Anzeichen gegeben habe.
Die Ergebnisse der Studie hÃ¤tten sich auch bei weiteren Obduktionen wiedergefunden, sagte der Direktor des Instituts fÃ¼r Rechtsmedizin, Klaus PÃ¼schel. Insgesamt seien in seinem Institut bisher 190 gestorbene Covid-19-Patienten untersucht worden.
Therapie mit blutverdÃ¼nnenden Mitteln empfohlen.
Die Ergebnisse hÃ¤tten auch Einfluss auf die Behandlung Erkrankter, sagte Kluge. â€Wir haben jetzt die MÃ¶glichkeit, einen Teil der Patienten zu behandeln mit BlutverdÃ¼nnern. Und das sollten wir auch tun.â€œ
Laut einer Studie des UniversitÃ¤tsklinikums Hamburg-Eppendorf hatten viele Corona-Tote Lungenembolien. Der Infektiologe Hans-Peter Hauber von der Asklepios-Klinik Altona im GesprÃ¤ch.
Dass in die den Angaben zufolge weltweit erster Studie dieser Art nur vergleichsweise wenig Obduktionen eingingen, sei auch dem Zeitfaktor geschuldet, sagte der Oberarzt des Instituts fÃ¼r Rechtsmedizin, Jan Sperhake. HÃ¤tte man mehr FÃ¤lle berÃ¼cksichtigt, â€wÃ¤ren wir nicht schnell genug gewesen. So einfach ist das.â€œ
Ein weiteres Ergebnis sind hÃ¤ufig festgestellte Nebenerkankungen bei verstorbenen Covid-19-Patienten an Lunge und Herz oder Krankheiten wie Parkinson und Demenz. Ãœbergewicht und Zuckerkrankheit scheinen laut Sperhake ein Risikofaktor zu sein. Insgesamt weisen die Ã„rzte aber darauf hin, dass weitere Folgeuntersuchungen fÃ¼r ein besseres Bild nÃ¶tig sind.<<
Und damit dÃ¼rfte klar sein, daÃŸ die meisten Ã„rzte gepennt haben oder schlimmer noch unfÃ¤hig sind sich selbst gegen VirusÃ¼bertragungen bei Obduktionen zu schÃ¼tzen.
Wie gut Ã„rzte sind kann man daran erkennen, daÃŸ die mir etliche ZÃ¤hne ziehen wollten. Bis auf die 4 WeisheitszÃ¤hne und einen vor einem Eckzahn habe ich noch alle ZÃ¤hne. Das zeigt: Traue niemals einem Arzt. ÃœberprÃ¼fe das, was die machen wollen.
Wie heiÃŸt es doch so schÃ¶n? Vertrauen ist gut, Kontrolle ist besser!
Der Disput erinnert mich an die schÃ¶nen Zeiten, als es in der Bibliothek des Jenaer ZEISS-Werkes noch keinerlei Literatur zur Programmierung gab und wir Fans einen ReAssembler geschrieben haben, um hinter die Tricks zu schauen, welche die Programmierer des Home-Computers Sinclair ZX81 angewendet haben, um in einem winzigen Chip nicht nur BASIC, sondern auch noch das Betriebssystem mit mehreren wichtigen Schnittstellen zur AuÃŸenwelt, wie Tastatur, Bildschirm und TonbandgerÃ¤t (zur austauschbaren Aufzeichnung geschriebener Programme in Z80-Assembler u. BASIC) unterzubringen.
Damals zerfiel diese Welt in die beiden Konkurrenten Sinclair mit dem ZX81 und Commodore mit dem C64, die sich die Ossis von wohlmeinenden Omas und Opas â€â€¦aus dem Westenâ€¦â€œ mitbringen lieÃŸen.
Es hat uns trotzdem nicht daran gehindert, uns auch mit FORTH und Assembler zu befassen und fÃ¼r den Winzling auch noch ein trickreiches Grafikprogramm zu schreiben (mit 256 x 192 Pixeln), also Punkt-Setzen, Linie-Ziehen, Kreisbogen und Vollkreis mit Stauchungs-Koeffizient fÃ¼r Ellipsen usw. Echtes Nostalgie-Feeling solche Erinnerungen!
Herzlichen Dank!
Meinereiner hatte vor der Wende beide â€“ ZX81 und dann C64, wobei eher der ZX Spectrum damals das â€GegenstÃ¼ckâ€œ zum C64 war.
Hier in Ilmenau an der TH gab es schon Jahre vor der Wende (!!!)einen â€Commodore-Computer-Clubâ€œ (Nutzer anderer â€Heimrechnerâ€œ waren natÃ¼rlich auch sehr willkommenâ€¦). Da wurde nicht nur â€gespieltâ€œ und kopiert, sondern auch â€DDR-typischeâ€œ Anwendungen â€gebasteltâ€œ, wie z.B. das Thema, aus einer Typenradschreibmaschine einen â€Quasi-Nadeldruckerâ€œ zu machen oder Ã¼berhaupt an den C64 zu bringen. Selbst Ã¼ber â€KIâ€œ auf dem C64 wurde gefachsimpelt â€¦.
Ich habe mit meinem C64 â€Pioniernachmittageâ€œ an unserer (Grund-) Schule gestaltet, wo viele Kinder Ã¼berhaupt erst mal mit Computern direkt in BerÃ¼hrung gekommen sind ((Geschicklichkeitsspiele, Ratespiele â€¦). Was ich den Kindern einleitend immer gesagt habe: Computer sind eigentlich ganz dumm, erst der Programmierer entscheidet, was der Computer kann oder auch nicht, womit der Bogen zum Fadenthema wieder hergestellt ist.
Ich bin leider nicht weit Ã¼ber Basicprogrammierung hinaus gekommen, hat aber bis heute fÃ¼r meine messtechnischen Anwendungen gereicht. Zu DDR-Zeiten hatten wir MessgerÃ¤te-Schnittstellen fÃ¼r den K1002 â€nachgebasteltâ€œ und jahrelang erfolgreich (bis nach der Wende) betrieben (bis die Magnetkarten nicht mehr funktioniertenâ€¦). Der Code war sehr â€maschinennahâ€œ, aber was wir da mit 2k Programmspeicher â€angestelltâ€œ haben, dafÃ¼r wÃ¼rde man heute einige MB brauchen â€¦..
PS: In der DDR wurden Programmiersprachen in MOPS und POPS unterschieden, aber das dÃ¼rfte Ihnen ja bekannt sein â€¦ ğŸ˜‰
â€Before the GitHub team started working on the code it was a single 15k line C file that had been worked on for a decade, and some of the functions looked like they were machine translated from Fortran. There are some tropes about academic code that have grains of truth, but \â€œ
https://twitter.com/ID_AA_Carmack/status/1254872369556074496
Zur Info fÃ¼r alle Egoshooter-Zocker der ersten Stunde:
John Carmack entwickelte unter anderem einen GroÃŸteil der Game-Engines von Doom und Quake !
VersÃ¶hnt wurde ich dann durch den Nachtrag. Da stand dann endlich, was wir alle schon wussten: Epidemiologische Modelle sind simpel und effizient, das Problem liegt in der AbschÃ¤tzung der Eingabeparameter, was gerade bei einer neuen Krankheit mit groÃŸen Unsicherheiten verbunden ist.
Dass Ferguson da anfangs suboptimal gehandelt hat, ist im Nachhinein leicht festzustellen. Interessant ist, dass es der Klimaforscher James Annan schon sofort gesagt hat und die Eingangsparameter besser bestimmt hat, siehe
http://julesandjames.blogspot.com/2020/04/blueskiesresearchorguk-model.html
Und hier sieht man sehr schÃ¶n, wie empfindlich die Prognosen auf VerÃ¤nderungen der Daten reagieren (logarithmische Skala beachten!):
http://julesandjames.blogspot.com/2020/04/reporting-delays-etc.html
Die in Gefangenschaft gehaltenen Menschen haben alles lÃ¤ngst durchschaut. Betrachten Sie die wunderbaren, schÃ¶nen Bilder vom gestrigen Mittwoch. Es ist alles so wie frÃ¼her, wie an jedem warmen, sonnigen Tag, nicht nur am Strand. Man hÃ¤lt keinen Abstand mehr.
Quelle:
https://www.dailymail.co.uk/news/article-8341971/PMs-plan-end-lockdown-TEN-DAYS.html
mir ist nicht klar, inwieweit ihr Beitrag einen Bezug zu meinem Post hat. KÃ¶nnten Sie das erlÃ¤utern?
Ich versuche mal einen herzustellen:
Ihre Bilder zeigen, dass nun eine neue Ã„ra anbricht. Wie werden sich dadurch die Eingabeparameter verÃ¤ndern? Schwer zu sagen, es ist ja eine neuartige Krankheit und es fehlen die Erfahrungen, welchen Einfluss diese VerÃ¤nderungen z.B. auf die Reproduktionsrate haben werden. Jede Modellierung der Zukunft ist also automatisch nur eine grobe AbschÃ¤tzung.
Mit GlÃ¼ck geht alles gut, mit Pech starten wir eine zweite Welle mit einem zweiten Lockdown. In diesem Falle hÃ¤tten wir wohl Probleme damit, die Bilder als â€wunderbarâ€œ zu bezeichnen.
Sie sind in â€Gefangenschaftâ€œ? Mein Beileid, da geht es mir weitaus besser.
Vielleicht zum Trost ein Kant-Zitat? Freiheit ist die Einsicht in Notwendigkeit.
â€Und hier sieht man sehr schÃ¶n, wie empfindlich die Prognosen auf VerÃ¤nderungen der Daten reagieren [â€¦]â€œ
1. Nennen Sie mir (alle) Staaten, die Daten absolut sicher validieren wollen und es auch kÃ¶nnen. Zur Erinnerung: Keine echte Validierung, keine Wissenschaft mÃ¶glich.
2. Der Hamburger Rechtsmediziner Prof. PÃ¼schel kann das. Er soll bei mittlerweile Ã¼ber 200 Leichen die Obduktion (Autopsie) durchgefÃ¼hrt haben. Die unfÃ¤hige Regierung ignoriert ihn und seine bemerkenswerten Resultate. Diese Tatsache allein, sollte bei Ihnen die Alarmglocken lÃ¤uten lassen. Wer PÃ¼schel ignoriert, macht automatisch Pseudo-Wissenschaft, will das Volk betrÃ¼gen.
3. Kant? Nein danke. Dann ist mir ein Stoiker lieber.
â€Die Krankheit ist ein Hindernis fÃ¼r den KÃ¶rper, nicht fÃ¼r den Willen, sofern dieser es nicht selbst so will.
Hinken ist ein Hindernis fÃ¼r das Bein, nicht fÃ¼r den Willen. Dies sage dir bei allem, was dich trifft. Dann wirst du finden, daÃŸ die Ereignisse immer ein Hindernis fÃ¼r etwas bilden, nicht aber fÃ¼r dich.â€œ (Epiktet, der Marcus Aurelius beeinflusst haben soll.)
4. Kant war einfÃ¤ltig und hat die Leute betrogen, sie dumm gemacht. Auch war er in der Freimaurerkirche zum Todtenkopf und der [albernen] PhÃ¶nix. Das mÃ¼ssten Sie als Kantianer wissen. Das ist Ihre Pflicht, wÃ¤re es. Und an die Auferstehung einer toten PhÃ¶nix glauben zu wollen, ist wirklich das Allerletzte, was ein Mensch brauchen kann. Und einen Totenkopf anbeten? Igitt.
Stoiker schlagen jeden Kantianer. ğŸ˜‰
5. Lesen Sie die anderen Artikel, vor allem auch die vielen klugen Kommentare, dann erkennen auch Sie, der Lockdown war ein sehr teurer und gemeiner Fehler, dieser Regierung in Berlin. Und fahren Sie (zur Not nur gedanklich) nach Taiwan. Die zeigen Ihnen, wie man damit richtig umgeht. Denn, mit Taiwan beschÃ¤ftigt sich kaum einer. Die werden auch ignoriert. Die kommunistisch gefÃ¼hrte WHO hat Taiwan aus der WHO hinaus befÃ¶rdert, weil die kriminellen Rotchinesen das so wollten. In Rotchina gibt es keine freie Meinung, kein freies Ã¶ffentliches Denken. Demnach wird auch dort keine echte Wissenschaft gedeihen kÃ¶nnen.
Die britischen BÃ¼rger sind weitaus klÃ¼ger als Merkel und ihre korrupten MÃ¶chtegern-Wissenschaftler.
Ich wollte damit nur sagen, andeuten, in Erinnerung rufen, in Assembler zu programmieren ist ungleich schwerer und zeitaufwendiger. Assembler hat noch andere Schwierigkeitsgrade, wie Prozessertyp, Lesbarkeit, tieferes VerstÃ¤ndnis der Materie.
Ich kann leider keine Assembler-Programmieurng. Hat sich nicht ergeben. Aber, fÃ¼r den, der sie beherrscht, bieten sich groÃŸe Vorteile.
Auch in C wollen Arrays gelernt sein.
Mit 30 Jahren Erfahrung sind Sie mir eindeutig Ã¼berlegen. Gratulation. Da kann ich nur von Ihnen lernen.
Seine Geliebte ist verheiratet. WÃ¤hrend des Lockdowns trafen sich beide, feierten Party, mit anderen womÃ¶glich zusammen, und setzten dem Ehemann die HÃ¶rner auf, ohne dessen Zustimmung.
Ferguson hielt sich also selbst nicht an seiner (unfachmÃ¤nnischen) Empfehlung. Das fÃ¼hrte dann auch zu seiner Entlassung. So las ich es zumindest.
Ferguson kann auch deshalb kein groÃŸer Denker sein, weil er so nebenbei die komplette Wirtschaft eines Landes ruiniert. Kompetenz ist etwas vÃ¶llig anderes.
Ferguson war noch nie Taiwan. Sollte er tun.
Erstens muss ich Herrn Heino MÃ¼ller Recht geben bezÃ¼glich Fortran. Man kann behaupten, Fortran ist die Mutter aller Programmiersprachen, moderne sehen ganz anders aus und haben viel mehr MÃ¶glichkeiten, sind aber gewissermaÃŸen alle Weiterentwicklungen von Fortran.
Zweitens: â€â€¦erfolgreich deterministische Modelle, die den Zufallsfaktor berÃ¼cksichtigen.â€œ Es wird dem Leser suggeriert, dass Modelle die ZufÃ¤lle berÃ¼cksichtigen kÃ¶nnte, die man in der Wirklichkeit nicht im Voraus einbeziehen kann. Das ist riesengroÃŸer Unfug. Um bei dem Beispiel vom Chirurgen und Herzpatienten zu bleiben: Bei jedem groÃŸen Eingriff kann es zum Tod des Patienten kommen, durch Zufall. Egal wie grÃ¼ndlich die Vorbereitung ist, manchmal stellt sich zum SchluÃŸ heraus, der Patient hÃ¤tte ohne der OP paar Monate gelebt, nun ist er tot. Zufall, nicht berechenbar. Zu welchen Thema auch immer, davon auszugehen, dass Computer Programme ZufÃ¤lle exakt zu vorherzusehenâ€¦ So eine Steigerungsform von Dummheit kann ich nicht formulieren.
Drittens: Es ist ein generationsÃ¼bergreifende und bildungsÃ¼bergreifende Problem unserer Gesellschaft, dass man i.d.R. Simulationsergebnisse nicht richtig einordnen kann, selbst unter vielen Eike-Lesern.
Der Klassiker: Wenn ich freudig mitteile, es ist 20 Grad warm, kommt aus der Umgebung hÃ¤ufig â€mein Handy zeigt aber nur 17 Grad an!â€œ Es ist ein allgemeines UnvermÃ¶gen bis Unwillen, zwischen Wirklichkeit (20 gemessen) und Simulation (17 vorhergesagt) zu differenzieren. Habe inzwischen die Lust verloren nachzufragen, welche Art von Thermometer das Handy hat, man erntet nur UnverstÃ¤ndnis. Es wird eben nicht differenziert, beide steht auf ein Display und ist also gleichwertig.
Den Lesern hier traue ich zu, den Unterschied in diesem Beispiel zu erkennen. Bei komplexeren Simulationen, die man inhaltlich nicht exakt nachvollziehen kann (Beispiel Klima), neigt auch hier wohl die Mehrheit dazu, Ã¼ber gute, schlechte, richtige oder fehlerhafte Simulation zu sprechen, anstatt auf den Punkt zu kommen:
Jede Simulation zeigt nur Eins von vielen mÃ¶glichen Ergebnissen. Die Wirklichkeit kÃ¶nnte nah dran sein, weit weg davon sein, manchmal auch exakt Ã¼bereinstimmen. Bei den Wettervorhersagen klar zu sehen, bei allen anderen komplexen Simulationen mit vielen Unbekannten und ZufÃ¤lle ist es nun mal genau so. Es ist nur eine MÃ¶glichkeit, ob es so kommt oder ganz anders, weiÃŸ nur der liebe Gott.
Damit kann eine Simulation unmÃ¶glich die Grundlage einer weitreichende Entscheidung sein. Wer das tut ist entweder vÃ¶llig unfÃ¤hig als Entscheider, oder ist ein BetrÃ¼ger, der die Simulation als Ausrede fÃ¼r seine Entscheidung vorschiebt. Eine Simulation mit welchen Ergebnis auch immer, kann nur eine von vielen Bausteine sein, die zur Entscheidungsfindung fÃ¼hren. Nicht mehr und nicht weniger.
Daher ist die Artikel-Aussage: â€Falsche Entscheidung, da auf Grundlage einer Simulation in der falschen Sprache getroffenâ€œ mehrfach inhaltlich absoluter Unsinn.
Komme zum Klima zurÃ¼ck und erneuere mein Angebot: gebt mit genug Geld und Zeit und ich erschaffe eine Klimasimulation die fÃ¼r das Jahr 2100 die Temperatur ihrer Wahl vorhersagt, in der Spanne von plus minus 5 gemÃ¤ÃŸ heute. Habe von Programmierung keine Ahnung, war aber lange genug Schnittstelle zwischen Kunde und Developer bei komplexen Berechnungen. Es wird so lange getrimmt, bis der Kundenwunsch erfÃ¼llt ist. Beim einer Klimasimulation wÃ¼rde ich zuerst den Programmierern vorschlagen, den CO2 EinfluÃŸ auf fast Null zu reduzieren und den SonneneinfluÃŸ zu erhÃ¶hen und entsprechende Schwankungen der Sonne einzubauenâ€¦
Woher kÃ¶nnte jemand exakt feststellen, dass â€meine Methodeâ€œ falscher sei als die von Ramstorf und Konsorten?
Nur mal so um den Glauben an heiligen Simulationen ein wenig zu erschÃ¼ttern!
Die Kritik ist berechtigt. Es kommt nicht auf die Programmiersprache an, sondern wie man sie nutzt.
Die Kritik ist berechtigt. Es kommt nicht auf die Programmiersprache an, sondern wie man sie nutzt.
Der Artikel wurde am 19.MÃ¤rz verfasst. Die Modellrechnung basiert auf bekannten Daten vor diesem Datum. Erst danach wurde der â€Shutdownâ€œ in England eingefÃ¼hrt. Wenn die damaligen Projektionen die Fallzahlen Ã¼berschÃ¤tzt haben ist dies nicht ein Fehler des Codes, sondern ein Beweis fÃ¼r die Wirksamkeit des Shutdowns.
https://www.deutsche-apotheker-zeitung.de/news/artikel/2020/04/06/shutdown-duerfte-bereits-zehntausende-tote-in-europa-verhindert-haben
Sie haben das Pandemie-Problem nicht verstanden. Ich verwende folgenden einfachen Ansatz. NA(t) ist die Zahl der aktiv infizierten, N0(t) die Anzahl der nicht infizierten und und nicht immunen lebenden Individuen. Dann gilt fÃ¼r die Wachstumsrate der aktiv infizierten Individuen dNA(t)= r(t)*NA(t)*N0(t). Der Koeffizient r(t) wird bestimmt durch (1) durch das Individuum selbst, (2) durch die Gebiets-Strukturen (BevÃ¶lkerungsdichte, Sozialverhalten usw.), (3) durch staatliche Eingriffe. Schweden kam ohne staatliche Eingriffe aus. Der Einfluss der staatlichen Eingriffe in Frankreich und in Deutschland ergibt sich wohl erst aus einer genaueren Analyse des Verlaufs der Fall-Zahlen.
verwenden Sie fÃ¼r die Zahl der aktiv Infizierten absolute Zahlen oder berÃ¼cksichtigen Sie das VerhÃ¤ltnis zwischen Infizierten und Anzahl der durchgefÃ¼hrten Tests? Und was die Wirksamkeit der MaÃŸnahmen angeht, kann man auf Euromomo sehr schÃ¶n sehen, dass es keine Korrelation zwischen Zeitpunkt sowie Art der MaÃŸnahmen und der Ãœbersterblichkeit gibt. Zur Problematik der absoluten Fallzahlen noch etwas Interessantes:
https://www.heise.de/tp/features/Die-Ueberschaetzung-des-tatsaechlichen-Anstiegs-der-Coronavirus-Neuinfektionen-4709977.html
Zustimmung. Kann man so sehen, kann man so verteidigen.
Ich habe mich selbst bereits mit Fortran beschÃ¤ftigt, einige Zeilen nachprogrammiert und hÃ¤tte gerne mehr Zeit darin investiert. Es gibt â€gefÃ¼hltâ€œ zig Varianten von Fortran. Oder zuviele davon.
FÃ¼r ein Virus und derem Verlauf dÃ¼rfte Fortran aber nicht die beste Wahl sein, sondern unnÃ¶tig kompliziert. Wie Sie selbst andeuten, muÃŸ man das Programmieren sehr gut beherrschen, um Fortran zu verwenden. Es gibt aber nicht so viele gute Programmierer.
Fortran wurde entwickelt, zu einer Zeit, in der man noch mit Lochkarten arbeitete. Daher ist das Schreiben von Fortran-Programmen am Lochkartenformat orientiert. ZusÃ¤tzlich ist jede Programmzeile in vier Bereiche eingeteilt. Zumindest bei der klassischen Fortran-Variante.
Fortran wurde bereits 1955 erfunden, bei IBM. Da gab es den Begriff â€computer scientistâ€œ noch gar nicht.
Was fÃ¼r Fortran spricht, ist seine sehr viel hÃ¶here Schnelligkeit. Die auch heutige High-Level-Sprachen Ã¼bertreffen soll, so Kupferschmidt im Jahr 2002.
Fortran ist weiterhin die Sprache (der Wahl) fÃ¼r Ingenierue, die Berechnungen durchfÃ¼hren wollen, mÃ¼ssen, die nicht alltÃ¤glich sind, nicht standardisierbar, fÃ¼r die noch keine Software programmiert wurde. Vor allem fÃ¼r Numerische Verfahren, nicht-lineare Gleichungssysteme. Und so fort.
Also, ich finde Fortran eine sehr interessante Sprache. Ob fÃ¼r die Kalkulation eines Virus so ein Riesenaufwand notwendig sein soll, das bezweifle ich sehr. Ein Mathebuch und etwas Papier hÃ¤tten auch gereicht. Keine Programmierung der Welt kann intensives Nachdenken, Reflektieren ersetzen. Das verstehen vor allem Linke nicht.
Danke, haben wir Ã¼bernommen. Die Kritik ist berechtigt. Es kommt nicht auf die Programmiersprache an, sondern wie man sie nutzt.
So sehr ich die BeitrÃ¤ge auf AchGut schÃ¤tze, lest bitte die Kommentare, bevor Ihr einen dort erschienen Beitrag â€nachdrucktâ€œ. Die Aussage der zitierten IT Experten sind inhaltlich als fortgeschritten dÃ¼mmlich zu bezeichnen. Ich will jetzt meinen VerriÃŸ vom AchGut Artikel nicht wiederholen. Aber, es gilt nach wie vor : garbage in, garbage out. FORTRAN ist eine Sprache aus dem technischen Bereich. NatÃ¼rlich gibt es heute Entwicklungssysteme, die komfortabler zu bedienen sind. Wenn aber die Simulation die Wirklichkeit nicht abbildet (siehe Klimasimulationen GW!!!!!!!!), dann liegt das am LÃ¶sungsdesign, nicht an der Programmiersprache!
Also die Programmiersprache hat letztendlich nichts mit der QualitÃ¤t eines Ergebnisses zu tun, sondern nur das Wissen und KÃ¶nnen des Programmierers.
Dann programmieren Sie doch mal das Gleiche in Assembler. Auch eine Programmiersprache.
Fortran does one thing (much better and easier) that C does not do: math.
In C programmieren, ist gleichbedeutend, mit einem Porsche zu fahren und in ein offenes Messer zu greifen.
Wieso gibt es dann so unglaublich viele Programmiersprachen? Wohl, weil jede Ã¼ber gewisse Vorteile verfÃ¼gen darf.
Manche Programmiersprachen provozieren leichter gewisse Fehler. Niemand ist frei von Denkfehlern. FÃ¼r die ist der Mensch allein verantwortlich. Oder nehmen Sie das Thema Arrays. Auch ein Kapitel fÃ¼r sich. In manchen Sprachen schwieriger, folglich fehleranfÃ¤lliger. Und Arrays sind wichtig. Wenn man mit groÃŸen Datenmengen zu tun hat. Vor allem dann.
Die Wahl der Programmiersprache entscheidet Ã¼ber, ist eine Funktion, der HÃ¤ufung der Programmierfehler. AuÃŸerdem gilt knallhart: mit steigender Zahl an Codezeilen, steigen auch die Programmierfehler. Und wie!! Manche Sprachen begÃ¼nstigen Fehler leichter als andere. Eine Binsenweisheit.
Fortran ist eine Programmiersprache, mit deren Hilfe ein Wissenschaftler oder auch Ingenieur Anweisungen formuliert (Code), die Ã¼ber den zugehÃ¶rigen Compiler dem Rechenwerk des Computers vermittelt, was es ausrechnen soll. Das tut Fortran weitestgehend fehlerfrei. Das Problem fehlerhaften Arbeitens liegt fast immer beim programmierenden Wissenschaftler, der sich bemÃ¼ht, (natÃ¼rliche) VorgÃ¤nge in ein numerisches Verfahren zu gieÃŸen, welches letztlich vom Compiler in ein digitales Zahlenspiel Ã¼bersetzt wird.
Fortran ist in vielen Bereichen noch immer die Programmiersprache der Wahl, aber wird leider kaum noch an UniversitÃ¤ten gelehrt.
Was nun genau am Covid-Computer-Modell des Imperial College faul ist, wird hier nicht dargelegt. Es ist mit Sicherheit nicht die Wahl der Programmiersprache.
Ich â€befehleâ€œ Ihnen, von nun an, nur noch in Assembler zu programmieren.
Danach werden Sie so einen Kommentar (hoffentlich) nie wieder von sich geben.
Jeder Programmierer macht in jeder Programmiersprache auf jeder Systemplattform irgendwelche Fehler â€¦ das war immer so und wird so bleiben. Reduzieren lÃ¤ÃŸt sich das nur durch Testen â€“ PrÃ¼fen -Testen â€“ PrÃ¼fen â€“ Testen â€¦ usw. â€¦ was bei umfangreichen wissenschaftlichen Rechenmodellen / Prognosen / â€mit der Hand am Armâ€œ schon schwierig ist.
Mit wachsender Anzahl von variablen Parametern und der Datenmenge wÃ¤chst das Problem â€¦
Aber: Wenn das Konzept schon fehlerhaft ist und dann noch unschlÃ¼ssige Daten einflieÃŸen gilt das immer noch gÃ¼ltige Grundprinzip â€“ Mist rein = Mist raus ğŸ™‚
Bitte hier nur unter vollem Klarnamen posten, siehe Regeln.
Ich stimme Ihnen zu. Man kann selbstverstÃ¤ndlich auch andere Programmiersprachen benutzen. Fortran ist sehr alt, was aber nicht dagegen spricht, es zu benutzen.
Die Kritik ist berechtigt. Es kommt nicht auf die Programmiersprache an, sondern wie man sie nutzt.